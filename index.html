<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#111827" />
  <title>Berlin Transit Quickboard</title>
  <style>
    :root { --bg:#0b1220; --card:#111827; --muted:#93a4b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#34d399; --warn:#fbbf24; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { position:sticky; top:0; background:rgba(11,18,32,.92); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,.08); padding:14px 14px 10px; z-index: 10; }
    h1 { font-size:16px; margin:0 0 10px; font-weight:700; letter-spacing:.2px; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { flex:1 1 30%; padding:10px 12px; border-radius:12px; background:var(--card); border:1px solid rgba(255,255,255,.08); color:var(--text); font-weight:700; cursor:pointer; }
    .tab.active { outline:2px solid rgba(96,165,250,.45); border-color: rgba(96,165,250,.45); }

    main { padding:14px; display:grid; gap:12px; max-width: 720px; margin:0 auto; }
    .card { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; }
    .card h2 { margin:0 0 10px; font-size:14px; }
    .row { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .muted { color:var(--muted); font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; align-items: center; }
    button { background:#0f172a; color:var(--text); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:12px; font-weight:700; cursor:pointer; }
    button.primary { background:rgba(96,165,250,.16); border-color: rgba(96,165,250,.45); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    button.tiny { padding:7px 10px; border-radius:10px; font-weight:800; }
    button.ghost { background: transparent; border-color: rgba(255,255,255,.18); }
    button.alertBtn { padding:6px 10px; border-radius:10px; font-weight:900; }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    td, th { padding:8px 6px; border-top:1px solid rgba(255,255,255,.08); vertical-align:top; }
    th { text-align:left; color:var(--muted); font-size:12px; font-weight:700; border-top:none; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); }
    .pill.ok { border-color: rgba(52,211,153,.5); color: var(--ok); }
    .pill.warn { border-color: rgba(251,191,36,.6); color: var(--warn); }
    .pill.bad { border-color: rgba(251,113,133,.6); color: var(--bad); }

    .grid2 { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 640px) { .grid2 { grid-template-columns: 1fr 1fr; } }

    input { width:100%; box-sizing:border-box; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#0f172a; color:var(--text); }
    .small { font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .error { color: var(--bad); font-size: 12px; margin-top: 8px; }
  </style>
</head>
<body>
<header>
  <h1>Berlin Transit Quickboard</h1>
  <div class="tabs">
    <button id="tab-home" class="tab active">Home</button>
    <button id="tab-work" class="tab">Work</button>
    <button id="tab-hbf" class="tab">Hauptbahnhof</button>
    <button id="tab-ost" class="tab">Ostkreuz</button>
    <button id="tab-sw" class="tab">SchÃ¶neweide</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="row">
      <div>
        <div id="modeTitle" style="font-weight:800; font-size:14px;">Home mode</div>
        <div id="modeSubtitle" class="muted">Altglienicke buses + S-Bahn options</div>
      </div>
      <div class="btnrow">
        <button id="btnRefresh" class="primary">Refresh</button>
        <button id="btnAuto">Auto: Off</button>
      </div>
    </div>
    <div class="muted" style="margin-top:8px;">
      Uses vbb.transport.rest (<span class="mono" id="apiBase"></span>). Data includes realtime delays when available.
    </div>
    <div id="status" class="muted" style="margin-top:8px;"></div>

    <div id="alertBar" class="muted" style="margin-top:8px; display:none;">
      <div class="row" style="align-items:center;">
        <div id="alertText" style="font-weight:800;"></div>
        <div class="btnrow">
          <button id="btnAlertCancel" class="tiny ghost">Cancel</button>
        </div>
      </div>
      <div id="alertMeta" class="muted small" style="margin-top:4px;"></div>
    </div>

    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div class="grid2">
    <div class="card">
      <h2>Departures</h2>
      <div class="muted">Top filtered departures. S-Bahn shows minimum 4 minutes (never 1â€“3). Tap ðŸ”” to set an alert.</div>
      <div id="departures"></div>
    </div>

    <div class="card" id="comparisonCard">
      <h2 id="comparisonTitle">Which option is better?</h2>
      <div class="muted" id="comparisonHint">Compares options using API data.</div>
      <div id="comparison"></div>
    </div>
  </div>

  <div class="card" id="homeOnlyCard">
    <h2>What train will I catch?</h2>
    <div class="muted">Estimates your arrival at the S-Bahn and shows the next departures you care about.</div>
    <div id="connections"></div>
    <div id="homeWork" style="margin-top:12px;"></div>
  </div>

  <div class="card">
    <h2>Settings (optional)</h2>
    <div class="muted">You can override stop names if autocomplete resolves the wrong one.</div>
    <div class="grid2" style="margin-top:10px;">
      <div>
        <div class="muted small">Home: primary bus stop</div>
        <input id="inHomeStopA" value="Altglienicke Kirche" />
      </div>
      <div>
        <div class="muted small">Home: secondary bus stop</div>
        <input id="inHomeStopB" value="Alter SchÃ¶nefelder Weg" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target A</div>
        <input id="inHomeTargetA" value="S Adlershof" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target B</div>
        <input id="inHomeTargetB" value="S Altglienicke" />
      </div>
      <div>
        <div class="muted small">Home: walk to stop (minutes)</div>
        <input id="inHomeWalk" value="0" />
      </div>

      <div>
        <div class="muted small">Work: S station</div>
        <input id="inWorkS" value="S Tiergarten" />
      </div>
      <div>
        <div class="muted small">Work: walk to Tiergarten (minutes)</div>
        <input id="inWorkWalk" value="7" />
      </div>

      <div>
        <div class="muted small">Regio: Hauptbahnhof stop name</div>
        <input id="inRegioHbf" value="Berlin Hbf" />
      </div>
      <div>
        <div class="muted small">Regio: Ostkreuz stop name</div>
        <input id="inRegioOst" value="S Ostkreuz" />
      </div>
      <div>
        <div class="muted small">Regio: SchÃ¶neweide stop name</div>
        <input id="inRegioSW" value="S SchÃ¶neweide" />
      </div>
    </div>
    <div class="btnrow" style="margin-top:10px;">
      <button id="btnSave">Save</button>
      <button id="btnReset">Reset</button>
    </div>
  </div>
</main>

<script>
  // =====================
  // Single-file app
  // =====================

  const API_BASE = 'https://v6.vbb.transport.rest';
  document.getElementById('apiBase').textContent = API_BASE;

  const state = {
    mode: 'home',
    auto: false,
    autoTimer: null,
    cache: new Map(), // stopName -> stopId

    last: {
      homeA: [], homeBAlt: [], homeBSW: [], homeAdlS: [], homeAltS: [],
      workS: [], hbf: [], ost: [], sw: []
    },

    alert: {
      active: false,
      mode: null,
      line: null,
      dest: null,
      whenIso: null,
      leadMin: 0,
      timerId: null,
    },

    cfg: {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter SchÃ¶nefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',

      homeLinesA: ['260', '163'],
      homeLinesB: ['160'],

      homeToStopMin: 0,

      workS: 'S Tiergarten',
      workToTiergartenMin: 7,

      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S SchÃ¶neweide',
    }
  };

  // ---------- persistence ----------
  const LS_KEY = 'btqb_cfg_v_alert1';
  function loadCfg() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      state.cfg = { ...state.cfg, ...parsed };
    } catch {}
  }
  function saveCfg() { localStorage.setItem(LS_KEY, JSON.stringify(state.cfg)); }

  // ---------- utils ----------
  const $ = (id) => document.getElementById(id);

  function setStatus(msg) { $('status').textContent = msg; }
  function setError(msg) {
    const el = $('err');
    if (!msg) { el.style.display = 'none'; el.textContent = ''; return; }
    el.style.display = 'block';
    el.textContent = msg;
  }

  function fmtTime(iso) {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  function isFuture(iso) {
    if (!iso) return false;
    return (new Date(iso).getTime() - Date.now()) > 0;
  }

  // S-Bahn must show "4 min" as smallest number (never 1â€“3).
  // Rows disappear only once time is in the past.
  function minutesFromNow(iso, minDisplay = 1) {
    if (!iso) return null;
    const ms = new Date(iso).getTime() - Date.now();
    if (ms <= 0) return null;
    const mins = Math.ceil(ms / 60000);
    return Math.max(minDisplay, mins);
  }

  function minDisplayForDeparture(d) {
    return (d?.line?.product === 'suburban') ? 4 : 1;
  }

  function pillClass(mins) {
    if (mins == null) return 'warn';
    if (mins <= 4) return 'bad';
    if (mins <= 8) return 'warn';
    return 'ok';
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"]+/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c] || c));
  }

  function norm(s) { return String(s || '').toUpperCase().replaceAll(' ', ''); }
  function bestDest(d) { return String(d?.direction || d?.destination?.name || d?.trip?.destination?.name || ''); }

  function containsAny(hay, needles) {
    const s = String(hay || '').toLowerCase();
    return needles.some(n => s.includes(String(n).toLowerCase()));
  }

  // ---------- API ----------
  async function fetchJson(url) {
    const res = await fetch(url, { headers: { 'accept': 'application/json' } });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.json();
  }

  async function resolveStopId(name) {
    if (!name || !name.trim()) throw new Error('Empty stop name');
    const key = name.trim();
    if (state.cache.has(key)) return state.cache.get(key);

    const q = encodeURIComponent(key);
    const url = `${API_BASE}/locations?query=${q}&stops=true&poi=false&addresses=false&results=10&fuzzy=true`;
    const arr = await fetchJson(url);
    if (!Array.isArray(arr) || arr.length === 0) throw new Error(`No station found for: ${key}`);

    const stopish = arr.find(x => (x.type === 'stop' || x.type === 'station')) || arr[0];
    const id = stopish?.id;
    if (!id) throw new Error(`No id for: ${key}`);

    state.cache.set(key, id);
    return id;
  }

  async function getDepartures(stopId, { results = 120, duration = 180, busOnly = false } = {}) {
    const params = new URLSearchParams();
    params.set('results', String(results));
    params.set('duration', String(duration));
    if (busOnly) {
      params.set('bus', 'true');
      params.set('suburban', 'false');
      params.set('subway', 'false');
      params.set('tram', 'false');
      params.set('ferry', 'false');
      params.set('express', 'false');
      params.set('regional', 'false');
    }
    const url = `${API_BASE}/stops/${encodeURIComponent(stopId)}/departures?${params.toString()}`;
    const resp = await fetchJson(url);
    if (Array.isArray(resp)) return resp;
    return resp?.departures || [];
  }

  async function getJourneys(fromId, toId, { results = 10 } = {}) {
    const params = new URLSearchParams();
    params.set('from', fromId);
    params.set('to', toId);
    params.set('results', String(results));
    return await fetchJson(`${API_BASE}/journeys?${params.toString()}`);
  }

  // Convert journeys into pseudo â€œdepartureâ€ rows so we can reuse the renderer
  function journeysToPseudoDepartures(journeysJson) {
    const js = journeysJson?.journeys || [];
    const out = [];

    for (const j of js) {
      const legs = Array.isArray(j?.legs) ? j.legs : [];
      if (!legs.length) continue;

      // pick first non-walk leg
      const serviceLeg = legs.find(l => l?.line?.name && l?.departure) || null;
      if (!serviceLeg?.departure || !serviceLeg?.line?.name) continue;

      const finalDest =
              legs.at(-1)?.destination?.name ||
              serviceLeg?.direction ||
              serviceLeg?.destination?.name ||
              '';

      out.push({
        when: serviceLeg.departure,
        plannedWhen: serviceLeg.plannedDeparture,
        platform: serviceLeg.departurePlatform,
        line: { name: serviceLeg.line?.name, product: serviceLeg.line?.product },
        direction: finalDest
      });
    }

    // dedupe
    const seen = new Set();
    const uniq = [];
    for (const d of out) {
      const k = `${norm(d.line?.name)}|${d.when}|${String(d.direction||'').toLowerCase()}`;
      if (seen.has(k)) continue;
      seen.add(k);
      uniq.push(d);
    }

    uniq.sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));
    return uniq;
  }

  // ---------- Rendering ----------
  function renderDepartureTable(title, deps) {
    const filtered = (deps || []).filter(d => isFuture(d.when || d.plannedWhen));
    if (!filtered.length) return `<div class="muted">${escapeHtml(title)}: no departures found.</div>`;

    const rows = filtered.map(d => {
      const when = d.when || d.plannedWhen;
      const mins = minutesFromNow(when, minDisplayForDeparture(d));
      if (mins == null) return '';

      const line = d.line?.name || 'â€”';
      const dir = bestDest(d);
      const plat = d.platform ? `Pl. ${d.platform}` : '';
      return `
        <tr>
          <td style="width:64px;"><span class="pill ${pillClass(mins)}">${mins} min</span></td>
          <td>
            <div><b>${escapeHtml(line)}</b> â†’ ${escapeHtml(dir)}</div>
            <div class="muted">${fmtTime(when)} ${escapeHtml(plat)}</div>
          </td>
          <td style="width:72px;">
            <button class="alertBtn" data-line="${escapeHtml(line)}" data-dest="${escapeHtml(dir)}" data-when="${escapeHtml(when)}">ðŸ””</button>
          </td>
        </tr>
      `;
    }).join('');

    return `
      <div class="muted" style="margin:6px 0 8px;">${escapeHtml(title)}</div>
      <table>
        <thead><tr><th>In</th><th>Service</th><th>Alert</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  // ---------- Filters ----------
  function homeBusAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');

    if (containsAny(d, ['Rudow', 'SchÃ¶nefeld'])) return false;

    if (ln === '260') return containsAny(d, ['Adlershof']);
    if (ln === '163') return containsAny(d, ['Adlershof', 'SchÃ¶neweide']);

    // 160 BOTH directions (split into separate tables in UI)
    if (ln === '160') return containsAny(d, ['Altglienicke', 'SchÃ¶neweide', 'Schoeneweide']);

    return false;
  }

  function workSAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '').toLowerCase();

    if (ln === 'S5') return d.includes('strausberg');
    if (ln === 'S7') return d.includes('ahrensfelde');
    if (ln === 'S3') return d.includes('erkner');
    if (ln === 'S9') {
      if (d.includes('spandau')) return false; // exclude Spandau always
      return (d.includes('flughafen') || d.includes('ber') || d.includes('terminal'));
    }
    return false;
  }

  function adlershofCityAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S8','S85','S46'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Birkenwerder', 'Westend', 'Pankow', 'Blankenburg']);
  }

  function altglienickeCityAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S85'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Birkenwerder', 'Westend', 'Pankow', 'Blankenburg']);
  }

  // =====================
  // Alerts
  // =====================
  function clearAlertTimer() {
    if (state.alert.timerId) clearTimeout(state.alert.timerId);
    state.alert.timerId = null;
  }

  function updateAlertBar() {
    const bar = $('alertBar');
    if (!state.alert.active) {
      bar.style.display = 'none';
      $('alertText').textContent = '';
      $('alertMeta').textContent = '';
      return;
    }
    bar.style.display = 'block';

    const depIso = state.alert.whenIso;
    const leadMin = state.alert.leadMin || 0;
    const depMs = depIso ? new Date(depIso).getTime() : null;
    const leaveMs = depMs ? (depMs - leadMin * 60000) : null;
    const triggerMs = depMs ? (depMs - (leadMin + 2) * 60000) : null;

    $('alertText').textContent = `Alert: ${state.alert.line} â†’ ${state.alert.dest}`;
    $('alertMeta').textContent =
            `Departure ${fmtTime(depIso)} Â· leave by ${leaveMs ? new Date(leaveMs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : 'â€”'} Â· alarm at ${triggerMs ? new Date(triggerMs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : 'â€”'} Â· lead=${leadMin} min`;
  }

  async function ensureNotificationPermission() {
    if (!('Notification' in window)) return;
    if (Notification.permission === 'default') {
      try { await Notification.requestPermission(); } catch {}
    }
  }

  function fireAlert(message) {
    if (navigator.vibrate) navigator.vibrate([600,200,600,200,900]);

    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 880;
      g.gain.value = 0.15;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(() => { o.stop(); ctx.close(); }, 900);
    } catch {}

    try {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('Transit alert', { body: message });
      }
    } catch {}
  }

  function scheduleAlertForDeparture({ mode, line, dest, whenIso, leadMin }) {
    clearAlertTimer();

    state.alert.active = true;
    state.alert.mode = mode;
    state.alert.line = line;
    state.alert.dest = dest;
    state.alert.whenIso = whenIso;
    state.alert.leadMin = Math.max(0, Number(leadMin) || 0);
    state.alert.timerId = null;

    updateAlertBar();

    const depMs = new Date(whenIso).getTime();
    const triggerMs = depMs - (state.alert.leadMin + 2) * 60000;
    const delay = triggerMs - Date.now();

    if (delay <= 0) {
      fireAlert(`${line} â†’ ${dest}: leave now`);
      return;
    }

    state.alert.timerId = setTimeout(() => {
      fireAlert(`${line} â†’ ${dest}: leave in 2 min`);
    }, delay);
  }

  function cancelAlert() {
    clearAlertTimer();
    state.alert.active = false;
    state.alert.mode = null;
    state.alert.line = null;
    state.alert.dest = null;
    state.alert.whenIso = null;
    state.alert.leadMin = 0;
    updateAlertBar();
  }

  function resyncAlertFromList(deps, leadMin) {
    if (!state.alert.active) return;
    if (!deps || !deps.length) return;

    const wantLine = norm(state.alert.line);
    const wantDest = String(state.alert.dest || '').toLowerCase();

    const candIso = (deps || [])
            .filter(d => norm(d.line?.name) === wantLine)
            .filter(d => bestDest(d).toLowerCase().includes(wantDest))
            .map(d => (d.when || d.plannedWhen))
            .filter(iso => isFuture(iso))
            .sort((a,b)=>new Date(a)-new Date(b))[0];

    if (candIso && candIso !== state.alert.whenIso) {
      scheduleAlertForDeparture({
        mode: state.alert.mode,
        line: state.alert.line,
        dest: state.alert.dest,
        whenIso: candIso,
        leadMin
      });
    }
  }

  // Unlock audio on first click (helps WebAudio beep)
  document.addEventListener('click', () => {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      ctx.resume();
      ctx.close();
    } catch {}
  }, { once: true });

  // =====================
  // Home mode
  // =====================
  async function loadHome() {
    const cfg = state.cfg;

    const [stopA, stopB, sAdlershof, sAltglienicke] = await Promise.all([
      resolveStopId(cfg.homeStopA),
      resolveStopId(cfg.homeStopB),
      resolveStopId(cfg.homeTargetA),
      resolveStopId(cfg.homeTargetB),
    ]);

    const [depsAAll, depsBAll] = await Promise.all([
      getDepartures(stopA, { busOnly: true, results: 160, duration: 180 }),
      getDepartures(stopB, { busOnly: true, results: 160, duration: 180 }),
    ]);

    const depsA = (depsAAll || [])
            .filter(d => cfg.homeLinesA.includes(d.line?.name))
            .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 10);

    const depsB160All = (depsBAll || [])
            .filter(d => cfg.homeLinesB.includes(d.line?.name))
            .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));

    const depsB_toAlt = depsB160All
            .filter(d => containsAny(bestDest(d), ['Altglienicke']))
            .slice(0, 8);

    const depsB_toSW = depsB160All
            .filter(d => containsAny(bestDest(d), ['SchÃ¶neweide', 'Schoeneweide']))
            .slice(0, 8);

    state.last.homeA = depsA;
    state.last.homeBAlt = depsB_toAlt;
    state.last.homeBSW = depsB_toSW;

    $('departures').innerHTML =
            renderDepartureTable(`${cfg.homeStopA}: 260/163 â†’ Adlershof (163 may also go SchÃ¶neweide)`, depsA)
            + `<div style="height:10px"></div>`
            + renderDepartureTable(`${cfg.homeStopB}: 160 â†’ Altglienicke`, depsB_toAlt)
            + `<div style="height:10px"></div>`
            + renderDepartureTable(`${cfg.homeStopB}: 160 â†’ SchÃ¶neweide (separate option)`, depsB_toSW);

    // journey estimates (kept for the comparison only)
    const [jAtoAdl, jBtoAlt] = await Promise.all([
      getJourneys(stopA, sAdlershof, { results: 1 }),
      getJourneys(stopB, sAltglienicke, { results: 1 }),
    ]);

    const arriveAdlershofIso = jAtoAdl?.journeys?.[0]?.legs?.at(-1)?.arrival || null;
    const arriveAltglienickeIso = jBtoAlt?.journeys?.[0]?.legs?.at(-1)?.arrival || null;

    // IMPORTANT: show ALL trains at Adlershof/Altglienicke (do not hide before arrival estimate)
    const [adlDepsAll, altDepsAll] = await Promise.all([
      getDepartures(sAdlershof, { busOnly: false, results: 360, duration: 240 }),
      getDepartures(sAltglienicke, { busOnly: false, results: 360, duration: 240 }),
    ]);

    const adlCityAll = (adlDepsAll || [])
            .filter(d => d.line?.product === 'suburban')
            .filter(d => adlershofCityAllowed(d.line?.name, bestDest(d)))
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 8);

    const altCityAll = (altDepsAll || [])
            .filter(d => d.line?.product === 'suburban')
            .filter(d => altglienickeCityAllowed(d.line?.name, bestDest(d)))
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 8);

    state.last.homeAdlS = adlCityAll;
    state.last.homeAltS = altCityAll;

    $('connections').innerHTML = `
      <div class="muted">${escapeHtml(cfg.homeStopA)} â†’ ${escapeHtml(cfg.homeTargetA)}</div>
      <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAdlershofIso)} (listing shows all trains)</div>
      ${renderDepartureTable(`${cfg.homeTargetA}: city-center S (includes S8 Blankenburg)`, adlCityAll)}
      <div style="height:10px"></div>
      <div class="muted">${escapeHtml(cfg.homeStopB)} â†’ ${escapeHtml(cfg.homeTargetB)}</div>
      <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAltglienickeIso)} (listing shows all trains)</div>
      ${renderDepartureTable(`${cfg.homeTargetB}: S9 + S85 (if present)`, altCityAll)}
    `;

    // Keep your original comparison: earliest catchable S9 â†’ Spandau after arrival estimate
    async function nextS9SpandauAfter(stationId, arrivalIso) {
      const depsAll = await getDepartures(stationId, { busOnly: false, results: 320, duration: 240 });
      const arrMs = arrivalIso ? new Date(arrivalIso).getTime() : Date.now();
      const cand = (depsAll || [])
              .filter(d => d.line?.product === 'suburban')
              .filter(d => norm(d.line?.name) === 'S9')
              .filter(d => containsAny(bestDest(d), ['Spandau']))
              .filter(d => new Date(d.when || d.plannedWhen).getTime() > arrMs)
              .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))[0];
      return cand || null;
    }

    function waitMins(arrivalIso, depIso) {
      if (!arrivalIso || !depIso) return null;
      const diffMs = new Date(depIso).getTime() - new Date(arrivalIso).getTime();
      if (diffMs <= 0) return null;
      return Math.max(1, Math.ceil(diffMs / 60000));
    }

    const [s9FromAdl, s9FromAlt] = await Promise.all([
      nextS9SpandauAfter(sAdlershof, arriveAdlershofIso),
      nextS9SpandauAfter(sAltglienicke, arriveAltglienickeIso),
    ]);

    const depAdlIso = s9FromAdl ? (s9FromAdl.when || s9FromAdl.plannedWhen) : null;
    const depAltIso = s9FromAlt ? (s9FromAlt.when || s9FromAlt.plannedWhen) : null;

    const optA = {
      label: `${cfg.homeStopA} â†’ ${cfg.homeTargetA} â†’ S9 (Spandau)`,
      arrive: arriveAdlershofIso,
      dep: depAdlIso,
      total: depAdlIso ? minutesFromNow(depAdlIso, 1) : null,
      wait: waitMins(arriveAdlershofIso, depAdlIso),
    };
    const optB = {
      label: `${cfg.homeStopB} â†’ ${cfg.homeTargetB} â†’ S9 (Spandau)`,
      arrive: arriveAltglienickeIso,
      dep: depAltIso,
      total: depAltIso ? minutesFromNow(depAltIso, 1) : null,
      wait: waitMins(arriveAltglienickeIso, depAltIso),
    };

    const opts = [optA, optB].sort((a,b) => (a.total ?? 1e9) - (b.total ?? 1e9));
    const best = opts[0];

    $('comparison').innerHTML = `
      <div class="muted" style="margin-bottom:8px;">Which is better? (earliest S9 â†’ Spandau you can catch after arrival estimate)</div>
      <div style="font-weight:800; margin-bottom:10px;">
        ${best.total == null ? 'No usable S9â†’Spandau found (check stop names/time window)' : escapeHtml(best.label)}
      </div>
      <table>
        <thead><tr><th>Total</th><th>Option</th></tr></thead>
        <tbody>
          ${opts.map(o => `
            <tr>
              <td style="width:82px;"><span class="pill ${(o===best && o.total!=null) ? 'ok' : 'warn'}">${o.total==null?'â€”':(o.total+' min')}</span></td>
              <td>
                <b>${escapeHtml(o.label)}</b>
                <div class="muted">Arrive ~ ${fmtTime(o.arrive)} Â· S9 dep ~ ${fmtTime(o.dep)} Â· Wait ~ ${o.wait==null?'â€”':(o.wait+' min')}</div>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;

    if (state.alert.active && state.alert.mode === 'home') {
      const leadMin = Number(state.cfg.homeToStopMin) || 0;
      const combined = [
        ...(state.last.homeA||[]),
        ...(state.last.homeBAlt||[]),
        ...(state.last.homeBSW||[]),
        ...(state.last.homeAdlS||[]),
        ...(state.last.homeAltS||[])
      ];
      resyncAlertFromList(combined, leadMin);
    }

    $('homeWork').innerHTML = '';
  }

  // =====================
  // Work mode
  // =====================
  async function loadWork() {
    const cfg = state.cfg;
    const tiergartenId = await resolveStopId(cfg.workS);

    const now = Date.now();
    const etaTiergarten = new Date(now + (Number(cfg.workToTiergartenMin) || 7) * 60000);

    const depsAll = await getDepartures(tiergartenId, { busOnly: false, results: 320, duration: 240 });

    const depsS = (depsAll || [])
            .filter(d => d.line?.product === 'suburban')
            .filter(d => workSAllowed(d.line?.name, bestDest(d)))
            .filter(d => new Date(d.when || d.plannedWhen).getTime() > etaTiergarten.getTime())
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 12);

    state.last.workS = depsS;

    const header = `
      <div class="muted" style="margin:6px 0 8px;">
        Buffer: work â†’ ${escapeHtml(cfg.workS)} <b>${Number(cfg.workToTiergartenMin)||7} min</b>.
        Earliest departure â‰¥ <b>${etaTiergarten.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</b>.
      </div>
    `;

    $('departures').innerHTML = header +
            renderDepartureTable(`${cfg.workS}: only S5â†’Strausberg, S7â†’Ahrensfelde, S3â†’Erkner, S9â†’Flughafen BER (no Spandau)`, depsS);

    $('comparison').innerHTML = `<div class="muted">Regio boards are in separate modes (Hauptbahnhof/Ostkreuz/SchÃ¶neweide).</div>`;

    if (state.alert.active && state.alert.mode === 'work') {
      const leadMin = Number(state.cfg.workToTiergartenMin) || 7;
      resyncAlertFromList(state.last.workS, leadMin);
    }
  }

  // =====================
  // Regio boards: robust direction via journeys
  // =====================
  async function loadRegioMode(which) {
    const cfg = state.cfg;

    const hbfId = await resolveStopId(cfg.regioHbfName);
    const ostId = await resolveStopId(cfg.regioOstkreuzName);
    const swId  = await resolveStopId(cfg.regioSchoneweideName);

    if (which === 'hbf') {
      // Keep your original RE1/RE2 logic from departures (works well)
      const depsAll = await getDepartures(hbfId, { busOnly: false, results: 360, duration: 300 });

      const main = (depsAll || [])
              .filter(d => ['regional','express'].includes(d.line?.product))
              .filter(d => ['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02'].map(norm).includes(norm(d.line?.name)))
              .filter(d => {
                const dest = bestDest(d).toLowerCase();
                return (dest.includes('frankfurt') && dest.includes('oder')) || dest.includes('cottbus');
              })
              .filter(d => isFuture(d.when || d.plannedWhen))
              .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
              .slice(0, 16);

      // RE7 towards Ostkreuz: journeys-based
      const j = await getJourneys(hbfId, ostId, { results: 14 });
      const pseudo = journeysToPseudoDepartures(j);
      const re7ToOst = pseudo.filter(d => norm(d.line?.name) === 'RE7').slice(0, 12);

      state.last.hbf = [...main, ...re7ToOst];

      $('departures').innerHTML =
              renderDepartureTable(`${cfg.regioHbfName}: RE2â†’Cottbus, RE1â†’Frankfurt (Oder)`, main) +
              `<div style="height:12px"></div>` +
              renderDepartureTable(`${cfg.regioHbfName}: RE7 â†’ Ostkreuz`, re7ToOst);

      $('comparison').innerHTML = `<div class="muted">Regio board mode.</div>`;
      return;
    }

    if (which === 'ost') {
      // Keep your â€œtowards Hbfâ€ filter from departures (as you had it)
      const depsAll = await getDepartures(ostId, { busOnly: false, results: 380, duration: 360 });
      const base = (depsAll || [])
              .filter(d => ['regional','express'].includes(d.line?.product))
              .filter(d => isFuture(d.when || d.plannedWhen))
              .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));

      const allowToHbf = new Set(['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02','RE7','RE 7','RE07','RE 07'].map(norm));
      const depsToHbf = base
              .filter(d => allowToHbf.has(norm(d.line?.name)))
              .filter(d => {
                const dest = bestDest(d).toLowerCase();
                return dest.includes('genthin') || dest.includes('dessau') || dest.includes('hennigsdorf');
              })
              .slice(0, 14);

      // Towards SchÃ¶neweide: journeys-based RB24/RB32/RE7
      const j = await getJourneys(ostId, swId, { results: 14 });
      const pseudo = journeysToPseudoDepartures(j);
      const toSW = pseudo.filter(d => ['RB24','RB32','RE7'].includes(norm(d.line?.name))).slice(0, 14);

      state.last.ost = [...depsToHbf, ...toSW];

      $('departures').innerHTML =
              renderDepartureTable(`${cfg.regioOstkreuzName}: towards Hauptbahnhof (RE1â†’Genthin, RE7â†’Dessau, RE2â†’Hennigsdorf)`, depsToHbf) +
              `<div style="height:12px"></div>` +
              renderDepartureTable(`${cfg.regioOstkreuzName}: towards SchÃ¶neweide (RB24/RB32/RE7)`, toSW);

      $('comparison').innerHTML = `<div class="muted">Regio board mode.</div>`;
      return;
    }

    if (which === 'sw') {
      // SchÃ¶neweide mode: both directions via journeys (robust)
      const jO = await getJourneys(swId, ostId, { results: 14 });
      const pseudoO = journeysToPseudoDepartures(jO);
      const toOst = pseudoO.filter(d => ['RB24','RB32','RE7'].includes(norm(d.line?.name))).slice(0, 14);

      const jH = await getJourneys(swId, hbfId, { results: 14 });
      const pseudoH = journeysToPseudoDepartures(jH);
      const toHbf = pseudoH.filter(d => ['RB24','RB32','RE7','RE1','RE2'].includes(norm(d.line?.name))).slice(0, 14);

      state.last.sw = [...toOst, ...toHbf];

      $('departures').innerHTML =
              renderDepartureTable(`${cfg.regioSchoneweideName}: towards Ostkreuz`, toOst) +
              `<div style="height:12px"></div>` +
              renderDepartureTable(`${cfg.regioSchoneweideName}: towards Hauptbahnhof`, toHbf);

      $('comparison').innerHTML = `<div class="muted">Regio board mode.</div>`;
      return;
    }

    throw new Error('Unknown Regio mode');
  }

  // =====================
  // App controls
  // =====================
  function applyCfgToInputs() {
    $('inHomeStopA').value = state.cfg.homeStopA;
    $('inHomeStopB').value = state.cfg.homeStopB;
    $('inHomeTargetA').value = state.cfg.homeTargetA;
    $('inHomeTargetB').value = state.cfg.homeTargetB;
    $('inHomeWalk').value = String(state.cfg.homeToStopMin || 0);
    $('inWorkS').value = state.cfg.workS;
    $('inWorkWalk').value = String(state.cfg.workToTiergartenMin || 7);
    $('inRegioHbf').value = state.cfg.regioHbfName;
    $('inRegioOst').value = state.cfg.regioOstkreuzName;
    $('inRegioSW').value = state.cfg.regioSchoneweideName;
  }

  function readInputsToCfg() {
    state.cfg.homeStopA = $('inHomeStopA').value.trim();
    state.cfg.homeStopB = $('inHomeStopB').value.trim();
    state.cfg.homeTargetA = $('inHomeTargetA').value.trim();
    state.cfg.homeTargetB = $('inHomeTargetB').value.trim();

    const hw = Number(($('inHomeWalk').value || '').trim());
    state.cfg.homeToStopMin = (Number.isFinite(hw) && hw >= 0) ? hw : 0;

    state.cfg.workS = $('inWorkS').value.trim();
    const ww = Number(($('inWorkWalk').value || '').trim());
    state.cfg.workToTiergartenMin = (Number.isFinite(ww) && ww > 0) ? ww : 7;

    state.cfg.regioHbfName = $('inRegioHbf').value.trim();
    state.cfg.regioOstkreuzName = $('inRegioOst').value.trim();
    state.cfg.regioSchoneweideName = $('inRegioSW').value.trim();

    state.cache.clear();
  }

  function setMode(mode) {
    state.mode = mode;
    ['home','work','hbf','ost','sw'].forEach(m => {
      const el = document.getElementById(`tab-${m}`);
      if (el) el.classList.toggle('active', m === mode);
    });

    $('modeTitle').textContent =
            mode === 'home' ? 'Home mode'
                    : mode === 'work' ? 'Work mode'
                            : mode === 'hbf' ? 'Hauptbahnhof mode'
                                    : mode === 'ost' ? 'Ostkreuz mode'
                                            : 'SchÃ¶neweide mode';

    $('modeSubtitle').textContent =
            mode === 'home' ? 'Altglienicke buses + S-Bahn options'
                    : mode === 'work' ? 'Tiergarten S-Bahn (strict directions)'
                            : 'Regio board';

    $('homeOnlyCard').style.display = (mode === 'home') ? 'block' : 'none';

    if (mode !== 'home') {
      $('connections').innerHTML = '';
      $('homeWork').innerHTML = '';
    }
  }

  async function refresh() {
    setError('');
    $('btnRefresh').disabled = true;
    const started = new Date();
    setStatus('Loadingâ€¦');

    try {
      if (state.mode === 'home') await loadHome();
      else if (state.mode === 'work') await loadWork();
      else if (state.mode === 'hbf') await loadRegioMode('hbf');
      else if (state.mode === 'ost') await loadRegioMode('ost');
      else if (state.mode === 'sw') await loadRegioMode('sw');

      setStatus(`Updated ${started.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`);
      updateAlertBar();
    } catch (e) {
      setError(String(e?.message || e));
      setStatus('');
    } finally {
      $('btnRefresh').disabled = false;
    }
  }

  function toggleAuto() {
    state.auto = !state.auto;
    $('btnAuto').textContent = state.auto ? 'Auto: On (60s)' : 'Auto: Off';
    if (state.auto) {
      refresh();
      state.autoTimer = setInterval(refresh, 60000);
    } else {
      if (state.autoTimer) clearInterval(state.autoTimer);
      state.autoTimer = null;
    }
  }

  // =====================
  // Wiring
  // =====================
  loadCfg();
  applyCfgToInputs();

  $('tab-home').addEventListener('click', () => { setMode('home'); refresh(); });
  $('tab-work').addEventListener('click', () => { setMode('work'); refresh(); });
  $('tab-hbf').addEventListener('click', () => { setMode('hbf'); refresh(); });
  $('tab-ost').addEventListener('click', () => { setMode('ost'); refresh(); });
  $('tab-sw').addEventListener('click', () => { setMode('sw'); refresh(); });

  $('btnRefresh').addEventListener('click', refresh);
  $('btnAuto').addEventListener('click', toggleAuto);

  $('btnSave').addEventListener('click', () => {
    readInputsToCfg();
    saveCfg();
    refresh();
  });

  $('btnReset').addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    state.cache.clear();
    state.cfg = {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter SchÃ¶nefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      homeLinesA: ['260','163'],
      homeLinesB: ['160'],
      homeToStopMin: 0,
      workS: 'S Tiergarten',
      workToTiergartenMin: 7,
      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S SchÃ¶neweide',
    };
    applyCfgToInputs();
    refresh();
  });

  $('btnAlertCancel').addEventListener('click', () => cancelAlert());

  // ðŸ”” click handling (event delegation)
  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.alertBtn');
    if (!btn) return;

    await ensureNotificationPermission();

    const line = btn.dataset.line;
    const dest = btn.dataset.dest;
    const whenIso = btn.dataset.when;

    const leadMin = (state.mode === 'work') ? (Number(state.cfg.workToTiergartenMin) || 7)
            : (state.mode === 'home') ? (Number(state.cfg.homeToStopMin) || 0)
                    : 0;

    if (state.mode !== 'home' && state.mode !== 'work') {
      setStatus('Alerts are available only in Home or Work mode.');
      return;
    }

    scheduleAlertForDeparture({ mode: state.mode, line, dest, whenIso, leadMin });
    setStatus(`Alert set: ${line} â†’ ${dest}`);
  });

  // Start
  setMode('home');
  refresh();
</script>
</body>
</html>
