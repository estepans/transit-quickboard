<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#111827" />
  <title>Berlin Transit Quickboard</title>
  <style>
    :root { --bg:#0b1220; --card:#111827; --muted:#93a4b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#34d399; --warn:#fbbf24; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { position:sticky; top:0; background:rgba(11,18,32,.92); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,.08); padding:14px 14px 10px; z-index:10; }
    h1 { font-size:16px; margin:0 0 10px; font-weight:700; letter-spacing:.2px; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { flex:1 1 30%; padding:10px 12px; border-radius:12px; background:var(--card); border:1px solid rgba(255,255,255,.08); color:var(--text); font-weight:800; cursor:pointer; }
    .tab.active { outline:2px solid rgba(96,165,250,.45); border-color: rgba(96,165,250,.45); }

    main { padding:14px; display:grid; gap:12px; max-width: 820px; margin:0 auto; }
    .card { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; }
    .card h2 { margin:0 0 10px; font-size:14px; }
    .row { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .muted { color:var(--muted); font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:#0f172a; color:var(--text); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:12px; font-weight:800; cursor:pointer; }
    button.primary { background:rgba(96,165,250,.16); border-color: rgba(96,165,250,.45); }
    button:disabled { opacity:.5; cursor:not-allowed; }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    td, th { padding:8px 6px; border-top:1px solid rgba(255,255,255,.08); vertical-align:top; }
    th { text-align:left; color:var(--muted); font-size:12px; font-weight:800; border-top:none; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); }
    .pill.ok { border-color: rgba(52,211,153,.5); color: var(--ok); }
    .pill.warn { border-color: rgba(251,191,36,.6); color: var(--warn); }
    .pill.bad { border-color: rgba(251,113,133,.6); color: var(--bad); }

    .grid2 { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 780px) { .grid2 { grid-template-columns: 1fr 1fr; } }

    input { width:100%; box-sizing:border-box; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#0f172a; color:var(--text); }
    .small { font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .error { color: var(--bad); font-size: 12px; margin-top: 8px; }
    .sep { height:10px; }
  </style>
</head>
<body>
<header>
  <h1>Berlin Transit Quickboard</h1>
  <div class="tabs">
    <button id="tab-home" class="tab active">Home</button>
    <button id="tab-work" class="tab">Work</button>
    <button id="tab-hbf" class="tab">Hauptbahnhof</button>
    <button id="tab-ost" class="tab">Ostkreuz</button>
    <button id="tab-sw" class="tab">Schöneweide</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="row">
      <div>
        <div id="modeTitle" style="font-weight:900; font-size:14px;">Home mode</div>
        <div id="modeSubtitle" class="muted">Altglienicke buses + S-Bahn options</div>
      </div>
      <div class="btnrow">
        <button id="btnRefresh" class="primary">Refresh</button>
        <button id="btnAuto">Auto: Off</button>
      </div>
    </div>
    <div class="muted" style="margin-top:8px;">
      Uses vbb.transport.rest (<span class="mono" id="apiBase"></span>). Times are realtime when available.
    </div>
    <div id="status" class="muted" style="margin-top:8px;"></div>
    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div class="grid2" id="gridMain">
    <div class="card">
      <h2>Departures</h2>
      <div class="muted">Minimum shown is 1 minute (no 0/negative).</div>
      <div id="departures"></div>
    </div>

    <div class="card" id="comparisonCard">
      <h2 id="comparisonTitle">Which option is better?</h2>
      <div class="muted" id="comparisonHint">Home: compares earliest catchable S9 → Spandau after you arrive at the S-Bahn.</div>
      <div id="comparison"></div>
    </div>
  </div>

  <div class="card" id="homeOnlyCard">
    <h2>What train will I catch?</h2>
    <div class="muted">After arriving at the S-Bahn (estimated), shows the next departures you care about.</div>
    <div id="connections"></div>
    <div id="homeWork" style="margin-top:12px;"></div>
  </div>

  <div class="card" id="settingsCard">
    <h2>Settings (optional)</h2>
    <div class="muted">Override stop names if lookup resolves the wrong one.</div>

    <div class="grid2" style="margin-top:10px;">
      <div>
        <div class="muted small">Home: primary bus stop</div>
        <input id="inHomeStopA" value="Altglienicke Kirche" />
      </div>
      <div>
        <div class="muted small">Home: secondary bus stop</div>
        <input id="inHomeStopB" value="Alter Schönefelder Weg" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target A</div>
        <input id="inHomeTargetA" value="S Adlershof" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target B</div>
        <input id="inHomeTargetB" value="S Altglienicke" />
      </div>

      <div>
        <div class="muted small">Work: S station</div>
        <input id="inWorkS" value="S Tiergarten" />
      </div>
      <div>
        <div class="muted small">Work: walk min (work → Tiergarten)</div>
        <input id="inWorkWalk" value="7" />
      </div>

      <div>
        <div class="muted small">Regio mode: Hauptbahnhof name</div>
        <input id="inRegioHbf" value="Berlin Hbf" />
      </div>
      <div>
        <div class="muted small">Regio mode: Ostkreuz name</div>
        <input id="inRegioOst" value="S Ostkreuz" />
      </div>
      <div>
        <div class="muted small">Regio mode: Schöneweide name</div>
        <input id="inRegioSW" value="S Schöneweide" />
      </div>
    </div>

    <div class="btnrow" style="margin-top:10px;">
      <button id="btnSave">Save</button>
      <button id="btnReset">Reset</button>
    </div>

    <div class="muted" style="margin-top:10px;">
      Note: if some destination wording differs (e.g., “Flughafen BER - Terminal 1-2”), update the allow-lists in code or tell me the exact text.
    </div>
  </div>
</main>

<script>
  // =====================
  // Core config / state
  // =====================
  const API_BASE = 'https://v6.vbb.transport.rest';
  document.getElementById('apiBase').textContent = API_BASE;

  const state = {
    mode: 'home', // home | work | hbf | ost | sw
    auto: false,
    autoTimer: null,
    cache: new Map(), // stopName -> stopId
    cfg: {
      // Home
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter Schönefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      // Home buses
      homeLinesA: ['260','163'], // must be towards Adlershof only
      homeLinesB: ['160'],      // must be towards Altglienicke only

      // Work
      workS: 'S Tiergarten',
      workToTiergartenMin: 7,

      // Regio mode stops
      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S Schöneweide',
    }
  };

  const LS_KEY = 'btqb_cfg_v3';

  // =====================
  // Helpers
  // =====================
  const $ = (id) => document.getElementById(id);

  function setStatus(msg) { $('status').textContent = msg; }
  function setError(msg) {
    const el = $('err');
    if (!msg) { el.style.display = 'none'; el.textContent = ''; return; }
    el.style.display = 'block';
    el.textContent = msg;
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"]+/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c] || c));
  }

  function fmtTime(iso) {
    if (!iso) return '—';
    const d = new Date(iso);
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  // Never show 0/negative minutes; minimum shown is 1 minute
  function minutesFromNow(iso) {
    if (!iso) return null;
    const ms = new Date(iso).getTime() - Date.now();
    if (ms <= 0) return null;
    return Math.max(1, Math.ceil(ms / 60000));
  }

  function pillClass(mins) {
    if (mins == null) return 'warn';
    if (mins <= 3) return 'bad';
    if (mins <= 8) return 'warn';
    return 'ok';
  }

  function norm(s) { return String(s || '').toUpperCase().replaceAll(' ', ''); }

  // Destination string (varies by API)
  function bestDest(d) {
    return String(d?.direction || d?.destination?.name || d?.trip?.destination?.name || '');
  }

  function containsAny(hay, needles) {
    const s = String(hay || '').toLowerCase();
    return needles.some(n => s.includes(String(n).toLowerCase()));
  }

  // =====================
  // STRICT direction filters (your requirement)
  // =====================
  // Home:
  // 260/163 ONLY towards Adlershof (exclude U Rudow, Schönefeld etc.)
  // 160 ONLY towards Altglienicke
  function homeBusAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (ln === '260' || ln === '163') return containsAny(d, ['Adlershof']);
    if (ln === '160') return containsAny(d, ['Altglienicke']);
    return false;
  }

  // Work (Tiergarten):
  // ONLY:
  // S5 → Strausberg (Nord)
  // S7 → Ahrensfelde
  // S3 → Erkner
  // S9 → Flughafen BER
  function workSAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (ln === 'S5') return containsAny(d, ['Strausberg']);
    if (ln === 'S7') return containsAny(d, ['Ahrensfelde']);
    if (ln === 'S3') return containsAny(d, ['Erkner']);
    if (ln === 'S9') return containsAny(d, ['Flughafen', 'BER', 'Terminal']);
    return false;
  }

  // Home city-center S from Adlershof: include S8 Blankenburg explicitly
  function adlershofCityAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S8','S85','S46'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Birkenwerder', 'Westend', 'Pankow', 'Blankenburg']);
  }

  // Altglienicke S-board: show S9 and S85 if present (but still only “city-ish” directions)
  function altglienickeAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S85'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Pankow', 'Westend', 'Birkenwerder', 'Blankenburg']);
  }

  // =====================
  // Persistence
  // =====================
  function loadCfg() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      state.cfg = { ...state.cfg, ...parsed };
    } catch {}
  }
  function saveCfg() { localStorage.setItem(LS_KEY, JSON.stringify(state.cfg)); }

  // =====================
  // API
  // =====================
  async function fetchJson(url) {
    const res = await fetch(url, { headers: { 'accept': 'application/json' } });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.json();
  }

  async function resolveStopId(name) {
    if (!name || !name.trim()) throw new Error('Empty stop name');
    const key = name.trim();
    if (state.cache.has(key)) return state.cache.get(key);

    // v6: /locations works reliably
    const q = encodeURIComponent(key);
    const url = `${API_BASE}/locations?query=${q}&stops=true&poi=false&addresses=false&results=10&fuzzy=true`;
    const arr = await fetchJson(url);
    if (!Array.isArray(arr) || arr.length === 0) throw new Error(`No station found for: ${key}`);

    const stopish = arr.find(x => (x.type === 'stop' || x.type === 'station')) || arr[0];
    const id = stopish?.id;
    if (!id) throw new Error(`No id for: ${key}`);

    state.cache.set(key, id);
    return id;
  }

  async function getDepartures(stopId, { results = 120, duration = 180, busOnly = false } = {}) {
    const params = new URLSearchParams();
    params.set('results', String(results));
    params.set('duration', String(duration));
    if (busOnly) {
      params.set('bus', 'true');
      params.set('suburban', 'false');
      params.set('subway', 'false');
      params.set('tram', 'false');
      params.set('ferry', 'false');
      params.set('express', 'false');
      params.set('regional', 'false');
    }
    const url = `${API_BASE}/stops/${encodeURIComponent(stopId)}/departures?${params.toString()}`;
    const resp = await fetchJson(url);
    if (Array.isArray(resp)) return resp;
    return resp?.departures || [];
  }

  async function getJourneys(fromId, toId, { results = 1 } = {}) {
    const params = new URLSearchParams();
    params.set('from', fromId);
    params.set('to', toId);
    params.set('results', String(results));
    const url = `${API_BASE}/journeys?${params.toString()}`;
    return await fetchJson(url);
  }

  // =====================
  // Rendering
  // =====================
  function renderDepartureTable(title, deps) {
    const filtered = (deps || []).filter(d => {
      const when = d.when || d.plannedWhen;
      const mins = minutesFromNow(when);
      return mins != null && mins >= 1;
    });

    if (!filtered.length) {
      return `<div class="muted">${escapeHtml(title)}: no upcoming departures found.</div>`;
    }

    const rows = filtered.map(d => {
      const when = d.when || d.plannedWhen;
      const mins = minutesFromNow(when);
      const line = d.line?.name || '—';
      const dir = bestDest(d);
      const plat = d.platform ? `Pl. ${d.platform}` : '';
      return `
        <tr>
          <td style="width:64px;"><span class="pill ${pillClass(mins)}">${mins} min</span></td>
          <td>
            <div><b>${escapeHtml(line)}</b> → ${escapeHtml(dir)}</div>
            <div class="muted">${fmtTime(when)} ${escapeHtml(plat)}</div>
          </td>
        </tr>
      `;
    }).join('');

    return `
      <div class="muted" style="margin:6px 0 8px;">${escapeHtml(title)}</div>
      <table>
        <thead><tr><th>In</th><th>Service</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  // =====================
  // Modes
  // =====================

  async function loadHome() {
    const cfg = state.cfg;

    // resolve ids
    const [stopA, stopB, sAdlershof, sAltglienicke] = await Promise.all([
      resolveStopId(cfg.homeStopA),
      resolveStopId(cfg.homeStopB),
      resolveStopId(cfg.homeTargetA),
      resolveStopId(cfg.homeTargetB),
    ]);

    // BUS departures: filter by line + strict destination rule
    const [depsAAll, depsBAll] = await Promise.all([
      getDepartures(stopA, { busOnly: true, results: 80, duration: 120 }),
      getDepartures(stopB, { busOnly: true, results: 80, duration: 120 }),
    ]);

    const depsA = (depsAAll || [])
      .filter(d => cfg.homeLinesA.includes(d.line?.name))
      .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 6);

    const depsB = (depsBAll || [])
      .filter(d => cfg.homeLinesB.includes(d.line?.name))
      .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 6);

    $('departures').innerHTML =
      renderDepartureTable(`${cfg.homeStopA}: 260/163 → Adlershof only`, depsA)
      + `<div class="sep"></div>`
      + renderDepartureTable(`${cfg.homeStopB}: 160 → Altglienicke only`, depsB);

    // Journeys: bus stop -> target S station
    const [jAtoAdl, jBtoAlt] = await Promise.all([
      getJourneys(stopA, sAdlershof, { results: 1 }),
      getJourneys(stopB, sAltglienicke, { results: 1 }),
    ]);

    const arriveAdlershofIso = jAtoAdl?.journeys?.[0]?.legs?.at(-1)?.arrival || null;
    const arriveAltglienickeIso = jBtoAlt?.journeys?.[0]?.legs?.at(-1)?.arrival || null;

    const arrAdlMs = arriveAdlershofIso ? new Date(arriveAdlershofIso).getTime() : null;
    const arrAltMs = arriveAltglienickeIso ? new Date(arriveAltglienickeIso).getTime() : null;

    // S departures after arrival
    const [adlDepsAll, altDepsAll] = await Promise.all([
      getDepartures(sAdlershof, { busOnly: false, results: 240, duration: 240 }),
      getDepartures(sAltglienicke, { busOnly: false, results: 240, duration: 240 }),
    ]);

    const adlCity = (adlDepsAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => adlershofCityAllowed(d.line?.name, bestDest(d)))
      .filter(d => {
        const t = new Date(d.when || d.plannedWhen).getTime();
        return arrAdlMs ? (t > arrAdlMs) : (t > Date.now());
      })
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 5);

    const altWanted = (altDepsAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => altglienickeAllowed(d.line?.name, bestDest(d))) // includes S85 if exists
      .filter(d => {
        const t = new Date(d.when || d.plannedWhen).getTime();
        return arrAltMs ? (t > arrAltMs) : (t > Date.now());
      })
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 5);

    $('connections').innerHTML = `
      <div class="muted">${escapeHtml(cfg.homeStopA)} → ${escapeHtml(cfg.homeTargetA)}</div>
      <div style="font-weight:900; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAdlershofIso)}</div>
      ${renderDepartureTable(`${cfg.homeTargetA}: S9/S8/S85 (+S8 Blankenburg)`, adlCity)}
      <div class="sep"></div>
      <div class="muted">${escapeHtml(cfg.homeStopB)} → ${escapeHtml(cfg.homeTargetB)}</div>
      <div style="font-weight:900; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAltglienickeIso)}</div>
      ${renderDepartureTable(`${cfg.homeTargetB}: S9 (Spandau) + S85 if present`, altWanted)}
    `;

    // Comparison: earliest catchable S9 → Spandau (after arrival) from each target station
    async function nextS9SpandauAfter(stationId, arrivalIso) {
      const depsAll = await getDepartures(stationId, { busOnly: false, results: 260, duration: 240 });
      const arrMs = arrivalIso ? new Date(arrivalIso).getTime() : Date.now();
      const cand = (depsAll || [])
        .filter(d => d.line?.product === 'suburban')
        .filter(d => norm(d.line?.name) === 'S9')
        .filter(d => containsAny(bestDest(d), ['Spandau']))
        .filter(d => new Date(d.when || d.plannedWhen).getTime() > arrMs)
        .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))[0];
      return cand || null;
    }

    function totalMinsToBoard(dep) {
      if (!dep) return null;
      return minutesFromNow(dep.when || dep.plannedWhen);
    }
    function waitMins(arrivalIso, dep) {
      if (!arrivalIso || !dep) return null;
      const depIso = dep.when || dep.plannedWhen;
      const diffMs = new Date(depIso).getTime() - new Date(arrivalIso).getTime();
      if (diffMs <= 0) return null;
      return Math.max(1, Math.ceil(diffMs / 60000));
    }

    const [s9FromAdl, s9FromAlt] = await Promise.all([
      nextS9SpandauAfter(sAdlershof, arriveAdlershofIso),
      nextS9SpandauAfter(sAltglienicke, arriveAltglienickeIso),
    ]);

    const optA = {
      label: `${cfg.homeStopA} → ${cfg.homeTargetA} → S9 (Spandau)`,
      arrive: arriveAdlershofIso,
      dep: s9FromAdl,
      total: totalMinsToBoard(s9FromAdl),
      wait: waitMins(arriveAdlershofIso, s9FromAdl),
    };
    const optB = {
      label: `${cfg.homeStopB} → ${cfg.homeTargetB} → S9 (Spandau)`,
      arrive: arriveAltglienickeIso,
      dep: s9FromAlt,
      total: totalMinsToBoard(s9FromAlt),
      wait: waitMins(arriveAltglienickeIso, s9FromAlt),
    };

    const opts = [optA, optB].sort((a,b) => (a.total ?? 1e9) - (b.total ?? 1e9));
    const best = opts[0];

    $('comparison').innerHTML = `
      <div class="muted" style="margin-bottom:8px;">Earliest S9 → Spandau after arriving at the station</div>
      <div style="font-weight:900; margin-bottom:10px;">
        ${best.total == null ? 'No usable S9→Spandau found (check stop names/time window).' : escapeHtml(best.label)}
      </div>
      <table>
        <thead><tr><th>Total</th><th>Option</th></tr></thead>
        <tbody>
          ${opts.map(o => `
            <tr>
              <td style="width:80px;"><span class="pill ${(o === best && o.total != null) ? 'ok' : 'warn'}">${o.total == null ? '—' : (o.total + ' min')}</span></td>
              <td>
                <b>${escapeHtml(o.label)}</b>
                <div class="muted">Arrive ~ ${fmtTime(o.arrive)} · S9 dep ~ ${fmtTime(o.dep ? (o.dep.when || o.dep.plannedWhen) : null)} · Wait ~ ${o.wait == null ? '—' : (o.wait + ' min')}</div>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
    `;

    $('homeWork').innerHTML = '';
  }

  async function loadWork() {
    const cfg = state.cfg;

    const tiergartenId = await resolveStopId(cfg.workS);
    const now = Date.now();
    const etaTiergarten = new Date(now + (Number(cfg.workToTiergartenMin) || 7) * 60000);

    const depsSAll = await getDepartures(tiergartenId, { busOnly: false, results: 260, duration: 240 });

    // STRICT: only desired lines + desired destinations (no Spandau/Westkreuz/etc.)
    const depsS = (depsSAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => workSAllowed(d.line?.name, bestDest(d)))
      .filter(d => new Date(d.when || d.plannedWhen).getTime() > etaTiergarten.getTime())
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 10);

    const header = `
      <div class="muted" style="margin:6px 0 8px;">
        Buffer: work → ${escapeHtml(cfg.workS)} <b>${Number(cfg.workToTiergartenMin) || 7} min</b>.
        Earliest departure ≥ <b>${etaTiergarten.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</b>.
      </div>
    `;

    $('departures').innerHTML =
      header + renderDepartureTable(`${cfg.workS}: only S5→Strausberg, S7→Ahrensfelde, S3→Erkner, S9→Flughafen BER`, depsS);

    $('comparison').innerHTML = `<div class="muted">Use the Regio modes (Hauptbahnhof/Ostkreuz/Schöneweide) for Regio boards.</div>`;
    $('connections').innerHTML = '';
    $('homeWork').innerHTML = '';
  }

  async function loadRegioMode(which) {
    const cfg = state.cfg;

    let stopName = '';
    let title = '';
    let allowLines = new Set();
    let destMatchers = [];

    if (which === 'hbf') {
      stopName = cfg.regioHbfName;
      title = `${stopName}: RE1/RE2 (your set)`;
      // User asked: RE2 Cottbus, RE1 Frankfurt (Oder)
      allowLines = new Set(['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02'].map(norm));
      destMatchers = [
        (dest) => (dest.includes('frankfurt') && dest.includes('oder')),
        (dest) => dest.includes('cottbus'),
      ];
    } else if (which === 'ost') {
      stopName = cfg.regioOstkreuzName;
      title = `${stopName}: RE1→Genthin, RE7→Dessau, RE2→Hennigsdorf`;
      allowLines = new Set(['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02','RE7','RE 7','RE07','RE 07'].map(norm));
      destMatchers = [
        (dest) => dest.includes('genthin'),
        (dest) => dest.includes('dessau'),
        (dest) => dest.includes('hennigsdorf'),
      ];
    } else if (which === 'sw') {
      stopName = cfg.regioSchoneweideName;
      title = `${stopName}: RB32/RB24 towards Ostkreuz/Hbf`;
      allowLines = new Set(['RB32','RB 32','RB24','RB 24'].map(norm));
      destMatchers = [
        (dest) => dest.includes('ostkreuz'),
        (dest) => dest.includes('hauptbahnhof') || dest.includes('berlin hbf') || dest === 'hbf',
      ];
    } else {
      throw new Error('Unknown Regio mode');
    }

    const stopId = await resolveStopId(stopName);
    const depsAll = await getDepartures(stopId, { busOnly: false, results: 320, duration: 300 });

    const deps = (depsAll || [])
      .filter(d => ['regional','express'].includes(d.line?.product))
      .filter(d => allowLines.has(norm(d.line?.name)))
      .filter(d => {
        const dest = bestDest(d).toLowerCase();
        return destMatchers.some(m => m(dest));
      })
      .filter(d => minutesFromNow(d.when || d.plannedWhen) != null)
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 14);

    $('departures').innerHTML = renderDepartureTable(title, deps);
    $('comparison').innerHTML = `<div class="muted">Regio board mode.</div>`;
    $('connections').innerHTML = '';
    $('homeWork').innerHTML = '';
  }

  // =====================
  // UI wiring
  // =====================
  function applyCfgToInputs() {
    $('inHomeStopA').value = state.cfg.homeStopA;
    $('inHomeStopB').value = state.cfg.homeStopB;
    $('inHomeTargetA').value = state.cfg.homeTargetA;
    $('inHomeTargetB').value = state.cfg.homeTargetB;
    $('inWorkS').value = state.cfg.workS;
    $('inWorkWalk').value = String(state.cfg.workToTiergartenMin);
    $('inRegioHbf').value = state.cfg.regioHbfName;
    $('inRegioOst').value = state.cfg.regioOstkreuzName;
    $('inRegioSW').value = state.cfg.regioSchoneweideName;
  }

  function readInputsToCfg() {
    state.cfg.homeStopA = $('inHomeStopA').value.trim();
    state.cfg.homeStopB = $('inHomeStopB').value.trim();
    state.cfg.homeTargetA = $('inHomeTargetA').value.trim();
    state.cfg.homeTargetB = $('inHomeTargetB').value.trim();
    state.cfg.workS = $('inWorkS').value.trim();

    const w = Number(($('inWorkWalk').value || '').trim());
    state.cfg.workToTiergartenMin = (Number.isFinite(w) && w > 0) ? w : 7;

    state.cfg.regioHbfName = $('inRegioHbf').value.trim();
    state.cfg.regioOstkreuzName = $('inRegioOst').value.trim();
    state.cfg.regioSchoneweideName = $('inRegioSW').value.trim();

    state.cache.clear();
  }

  function setMode(mode) {
    state.mode = mode;

    ['home','work','hbf','ost','sw'].forEach(m => {
      const el = document.getElementById(`tab-${m}`);
      if (el) el.classList.toggle('active', m === mode);
    });

    // Toggle section visibility
    const homeCard = $('homeOnlyCard');
    const comparisonCard = $('comparisonCard');

    if (mode === 'home') {
      $('modeTitle').textContent = 'Home mode';
      $('modeSubtitle').textContent = 'Altglienicke buses + S-Bahn options';
      $('comparisonHint').textContent = 'Home: compares earliest catchable S9 → Spandau after you arrive at the S-Bahn.';
      homeCard.style.display = 'block';
      comparisonCard.style.display = 'block';
    } else if (mode === 'work') {
      $('modeTitle').textContent = 'Work mode';
      $('modeSubtitle').textContent = `${state.cfg.workS} (strict directions)`;
      $('comparisonHint').textContent = 'Work: Regio boards are in separate modes.';
      homeCard.style.display = 'none';
      comparisonCard.style.display = 'block';
    } else if (mode === 'hbf') {
      $('modeTitle').textContent = 'Hauptbahnhof mode';
      $('modeSubtitle').textContent = 'Regio board';
      homeCard.style.display = 'none';
      comparisonCard.style.display = 'none';
    } else if (mode === 'ost') {
      $('modeTitle').textContent = 'Ostkreuz mode';
      $('modeSubtitle').textContent = 'Regio board';
      homeCard.style.display = 'none';
      comparisonCard.style.display = 'none';
    } else if (mode === 'sw') {
      $('modeTitle').textContent = 'Schöneweide mode';
      $('modeSubtitle').textContent = 'Regio board';
      homeCard.style.display = 'none';
      comparisonCard.style.display = 'none';
    }
  }

  async function refresh() {
    setError('');
    $('btnRefresh').disabled = true;
    const started = new Date();
    setStatus('Loading…');
    try {
      if (state.mode === 'home') await loadHome();
      else if (state.mode === 'work') await loadWork();
      else if (state.mode === 'hbf') await loadRegioMode('hbf');
      else if (state.mode === 'ost') await loadRegioMode('ost');
      else if (state.mode === 'sw') await loadRegioMode('sw');
      setStatus(`Updated ${started.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`);
    } catch (e) {
      setError(String(e?.message || e));
      setStatus('');
    } finally {
      $('btnRefresh').disabled = false;
    }
  }

  function toggleAuto() {
    state.auto = !state.auto;
    $('btnAuto').textContent = state.auto ? 'Auto: On (60s)' : 'Auto: Off';
    if (state.auto) {
      refresh();
      state.autoTimer = setInterval(refresh, 60000);
    } else {
      if (state.autoTimer) clearInterval(state.autoTimer);
      state.autoTimer = null;
    }
  }

  // Init
  loadCfg();
  applyCfgToInputs();

  $('tab-home').addEventListener('click', () => { setMode('home'); refresh(); });
  $('tab-work').addEventListener('click', () => { setMode('work'); refresh(); });
  $('tab-hbf').addEventListener('click', () => { setMode('hbf'); refresh(); });
  $('tab-ost').addEventListener('click', () => { setMode('ost'); refresh(); });
  $('tab-sw').addEventListener('click', () => { setMode('sw'); refresh(); });

  $('btnRefresh').addEventListener('click', refresh);
  $('btnAuto').addEventListener('click', toggleAuto);

  $('btnSave').addEventListener('click', () => {
    readInputsToCfg();
    saveCfg();
    refresh();
  });

  $('btnReset').addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    state.cache.clear();
    state.cfg = {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter Schönefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      homeLinesA: ['260','163'],
      homeLinesB: ['160'],
      workS: 'S Tiergarten',
      workToTiergartenMin: 7,
      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S Schöneweide',
    };
    applyCfgToInputs();
    refresh();
  });

  setMode('home');
  refresh();
</script>
</body>
</html>
