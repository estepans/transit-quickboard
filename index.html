<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#111827" />
  <title>Berlin Transit Quickboard</title>
  <style>
    :root { --bg:#0b1220; --card:#111827; --muted:#93a4b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#34d399; --warn:#fbbf24; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { position:sticky; top:0; background:rgba(11,18,32,.92); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,.08); padding:14px 14px 10px; z-index: 10; }
    h1 { font-size:16px; margin:0 0 10px; font-weight:700; letter-spacing:.2px; }
    .tabs { display:flex; gap:8px; flex-wrap:wrap; }
    .tab { flex:1 1 30%; padding:10px 12px; border-radius:12px; background:var(--card); border:1px solid rgba(255,255,255,.08); color:var(--text); font-weight:700; cursor:pointer; }
    .tab.active { outline:2px solid rgba(96,165,250,.45); border-color: rgba(96,165,250,.45); }

    main { padding:14px; display:grid; gap:12px; max-width: 720px; margin:0 auto; }
    .card { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; }
    .card h2 { margin:0 0 10px; font-size:14px; }
    .row { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .muted { color:var(--muted); font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; align-items: center; }
    button { background:#0f172a; color:var(--text); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:12px; font-weight:700; cursor:pointer; }
    button.primary { background:rgba(96,165,250,.16); border-color: rgba(96,165,250,.45); }
    button:disabled { opacity:.5; cursor:not-allowed; }
    button.tiny { padding:7px 10px; border-radius:10px; font-weight:800; }
    button.ghost { background: transparent; border-color: rgba(255,255,255,.18); }
    button.alertBtn { padding:6px 10px; border-radius:10px; font-weight:900; }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    td, th { padding:8px 6px; border-top:1px solid rgba(255,255,255,.08); vertical-align:top; }
    th { text-align:left; color:var(--muted); font-size:12px; font-weight:700; border-top:none; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); }
    .pill.ok { border-color: rgba(52,211,153,.5); color: var(--ok); }
    .pill.warn { border-color: rgba(251,191,36,.6); color: var(--warn); }
    .pill.bad { border-color: rgba(251,113,133,.6); color: var(--bad); }

    .grid2 { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 640px) { .grid2 { grid-template-columns: 1fr 1fr; } }

    input { width:100%; box-sizing:border-box; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#0f172a; color:var(--text); }
    .small { font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .error { color: var(--bad); font-size: 12px; margin-top: 8px; }
    .ok { color: var(--ok); }
    .warn { color: var(--warn); }
  </style>
</head>
<body>
<header>
  <h1>Berlin Transit Quickboard</h1>
  <div class="tabs">
    <button id="tab-home" class="tab active">Home</button>
    <button id="tab-work" class="tab">Work</button>
    <button id="tab-hbf" class="tab">Hauptbahnhof</button>
    <button id="tab-ost" class="tab">Ostkreuz</button>
    <button id="tab-sw" class="tab">SchÃ¶neweide</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="row">
      <div>
        <div id="modeTitle" style="font-weight:800; font-size:14px;">Home mode</div>
        <div id="modeSubtitle" class="muted">Altglienicke buses + S-Bahn options</div>
      </div>
      <div class="btnrow">
        <button id="btnRefresh" class="primary">Refresh</button>
        <button id="btnAuto">Auto: Off</button>
      </div>
    </div>
    <div class="muted" style="margin-top:8px;">
      Uses vbb.transport.rest (<span class="mono" id="apiBase"></span>). Data includes realtime delays when available.
    </div>
    <div id="status" class="muted" style="margin-top:8px;"></div>
    <div id="alertBar" class="muted" style="margin-top:8px; display:none;">
      <div class="row" style="align-items:center;">
        <div id="alertText" style="font-weight:800;"></div>
        <div class="btnrow">
          <button id="btnAlertCancel" class="tiny ghost">Cancel</button>
        </div>
      </div>
      <div id="alertMeta" class="muted small" style="margin-top:4px;"></div>
    </div>
    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div class="grid2">
    <div class="card">
      <h2>Departures</h2>
      <div class="muted">
        Top filtered departures. Buses/regio show minimum 1 minute. S-Bahn shows minimum 3 minutes (never 1â€“2). Tap ðŸ”” to set an alert.
      </div>
      <div id="departures"></div>
    </div>

    <div class="card" id="comparisonCard">
      <h2 id="comparisonTitle">Which option is better?</h2>
      <div class="muted" id="comparisonHint">Compares options using API data.</div>
      <div id="comparison"></div>
    </div>
  </div>

  <div class="card" id="homeOnlyCard">
    <h2>What train will I catch?</h2>
    <div class="muted">Estimates your arrival at the S-Bahn and shows the next departures you care about.</div>
    <div id="connections"></div>
    <div id="homeWork" style="margin-top:12px;"></div>
  </div>

  <div class="card">
    <h2>Settings (optional)</h2>
    <div class="muted">You can override stop names if autocomplete resolves the wrong one.</div>
    <div class="grid2" style="margin-top:10px;">
      <div>
        <div class="muted small">Home: primary bus stop</div>
        <input id="inHomeStopA" value="Altglienicke Kirche" />
      </div>
      <div>
        <div class="muted small">Home: secondary bus stop</div>
        <input id="inHomeStopB" value="Alter SchÃ¶nefelder Weg" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target A</div>
        <input id="inHomeTargetA" value="S Adlershof" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target B</div>
        <input id="inHomeTargetB" value="S Altglienicke" />
      </div>
      <div>
        <div class="muted small">Home: walk to stop (minutes)</div>
        <input id="inHomeWalk" value="0" />
      </div>

      <div>
        <div class="muted small">Work: S station</div>
        <input id="inWorkS" value="S Tiergarten" />
      </div>
      <div>
        <div class="muted small">Work: walk to Tiergarten (minutes)</div>
        <input id="inWorkWalk" value="7" />
      </div>

      <div>
        <div class="muted small">Regio: Hauptbahnhof stop name</div>
        <input id="inRegioHbf" value="Berlin Hbf" />
      </div>
      <div>
        <div class="muted small">Regio: Ostkreuz stop name</div>
        <input id="inRegioOst" value="S Ostkreuz" />
      </div>
      <div>
        <div class="muted small">Regio: SchÃ¶neweide stop name</div>
        <input id="inRegioSW" value="S SchÃ¶neweide" />
      </div>
    </div>
    <div class="btnrow" style="margin-top:10px;">
      <button id="btnSave">Save</button>
      <button id="btnReset">Reset</button>
    </div>
  </div>
</main>

<script>
  // =====================
  // Minimal Android-friendly web app (single file)
  // =====================

  const API_BASE = 'https://v6.vbb.transport.rest';
  document.getElementById('apiBase').textContent = API_BASE;

  const state = {
    mode: 'home',
    auto: false,
    autoTimer: null,
    cache: new Map(), // stopName -> stopId

    // for resyncing alert after refresh
    last: { homeA: [], homeB: [], homeAdlS: [], homeAltS: [], workS: [], hbf: [], ost: [], sw: [] },

    // alert state
    alert: {
      active: false,
      mode: null,        // 'home' | 'work'
      line: null,
      dest: null,
      whenIso: null,
      leadMin: 0,
      timerId: null,
    },

    cfg: {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter SchÃ¶nefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',

      // preferences
      homeLinesA: ['260', '163'],
      homeLinesB: ['160'],

      // home walking time to reach the stop
      homeToStopMin: 0,

      // Work preferences
      workS: 'S Tiergarten',
      workToTiergartenMin: 7,

      // Regio mode stop names
      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S SchÃ¶neweide',
    }
  };

  // ---------- persistence ----------
  const LS_KEY = 'btqb_cfg_v_alert1';
  function loadCfg() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      state.cfg = { ...state.cfg, ...parsed };
    } catch {}
  }
  function saveCfg() { localStorage.setItem(LS_KEY, JSON.stringify(state.cfg)); }

  // ---------- utils ----------
  const $ = (id) => document.getElementById(id);

  function setStatus(msg) { $('status').textContent = msg; }
  function setError(msg) {
    const el = $('err');
    if (!msg) { el.style.display = 'none'; el.textContent = ''; return; }
    el.style.display = 'block';
    el.textContent = msg;
  }

  function fmtTime(iso) {
    if (!iso) return 'â€”';
    const d = new Date(iso);
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  function isFuture(iso) {
    if (!iso) return false;
    return (new Date(iso).getTime() - Date.now()) > 0;
  }

  // Minutes until departure with configurable minimum display clamp.
  function minutesFromNow(iso, minDisplay = 1) {
    if (!iso) return null;
    const ms = new Date(iso).getTime() - Date.now();
    if (ms <= 0) return null;
    const mins = Math.ceil(ms / 60000);
    return Math.max(minDisplay, mins);
  }

  function pillClass(mins) {
    if (mins == null) return 'warn';
    if (mins <= 3) return 'bad';
    if (mins <= 8) return 'warn';
    return 'ok';
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"]+/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c] || c));
  }

  function norm(s) { return String(s || '').toUpperCase().replaceAll(' ', ''); }

  function bestDest(d) {
    return String(d?.direction || d?.destination?.name || d?.trip?.destination?.name || '');
  }

  function containsAny(hay, needles) {
    const s = String(hay || '').toLowerCase();
    return needles.some(n => s.includes(String(n).toLowerCase()));
  }

  // S-Bahn (suburban) shows minimum 3 minutes always.
  function minDisplayForDeparture(d) {
    return (d?.line?.product === 'suburban') ? 3 : 1;
  }

  // Stopover matcher (used for Ostkreuz â†’ SchÃ¶neweide, where destination text is often not SchÃ¶neweide)
  function hasStopover(d, needle) {
    const n = String(needle || '').toLowerCase();
    const arr = d?.stopovers;
    if (!Array.isArray(arr)) return false;
    return arr.some(s => String(s?.stop?.name || '').toLowerCase().includes(n));
  }

  // =====================
  // Home / Work filters
  // =====================

  // Home: 260/163 should go to Adlershof; BUT 163 may go to SchÃ¶neweide daytime.
  // Also block Rudow/SchÃ¶nefeld.
  function homeBusAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');

    if (containsAny(d, ['Rudow', 'SchÃ¶nefeld'])) return false;

    if (ln === '260') return containsAny(d, ['Adlershof']);
    if (ln === '163') return containsAny(d, ['Adlershof', 'SchÃ¶neweide']);
    if (ln === '160') return containsAny(d, ['Altglienicke']);
    return false;
  }

  // Work: only the directions you want (S9 ONLY Flughafen/BER; never Spandau)
  function workSAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '').toLowerCase();

    if (ln === 'S5') return d.includes('strausberg');
    if (ln === 'S7') return d.includes('ahrensfelde');
    if (ln === 'S3') return d.includes('erkner');

    if (ln === 'S9') {
      // Hard exclude any Spandau string variants
      if (d.includes('spandau')) return false;
      // Accept only BER/Flughafen/Terminal variants
      return (d.includes('flughafen') || d.includes('ber') || d.includes('terminal'));
    }
    return false;
  }

  // Home: city-center from Adlershof; include S8 Blankenburg if present
  function adlershofCityAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S8','S85','S46'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Birkenwerder', 'Westend', 'Pankow', 'Blankenburg']);
  }

  // Home: from Altglienicke; include S9 plus S85 if it exists
  function altglienickeCityAllowed(lineName, dest) {
    const ln = norm(lineName);
    const d = String(dest || '');
    if (!['S9','S85'].includes(ln)) return false;
    return containsAny(d, ['Spandau', 'Birkenwerder', 'Westend', 'Pankow', 'Blankenburg']);
  }

  // =====================
  // Alert feature
  // =====================
  function clearAlertTimer() {
    if (state.alert.timerId) clearTimeout(state.alert.timerId);
    state.alert.timerId = null;
  }

  function updateAlertBar() {
    const bar = $('alertBar');
    if (!state.alert.active) {
      bar.style.display = 'none';
      $('alertText').textContent = '';
      $('alertMeta').textContent = '';
      return;
    }
    bar.style.display = 'block';

    const depIso = state.alert.whenIso;
    const leadMin = state.alert.leadMin || 0;
    const depMs = depIso ? new Date(depIso).getTime() : null;
    const leaveMs = depMs ? (depMs - leadMin * 60000) : null;
    const triggerMs = depMs ? (depMs - (leadMin + 2) * 60000) : null;

    $('alertText').textContent = `Alert: ${state.alert.line} â†’ ${state.alert.dest}`;
    $('alertMeta').textContent =
            `Departure ${fmtTime(depIso)} Â· leave by ${leaveMs ? new Date(leaveMs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : 'â€”'} Â· alarm at ${triggerMs ? new Date(triggerMs).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'}) : 'â€”'} Â· lead=${leadMin} min`;
  }

  async function ensureNotificationPermission() {
    if (!('Notification' in window)) return;
    if (Notification.permission === 'default') {
      try { await Notification.requestPermission(); } catch {}
    }
  }

  function fireAlert(message) {
    if (navigator.vibrate) navigator.vibrate([600,200,600,200,900]);

    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = 'sine';
      o.frequency.value = 880;
      g.gain.value = 0.15;
      o.connect(g); g.connect(ctx.destination);
      o.start();
      setTimeout(() => { o.stop(); ctx.close(); }, 900);
    } catch {}

    try {
      if ('Notification' in window && Notification.permission === 'granted') {
        new Notification('Transit alert', { body: message });
      }
    } catch {}
  }

  function scheduleAlertForDeparture({ mode, line, dest, whenIso, leadMin }) {
    clearAlertTimer();

    state.alert.active = true;
    state.alert.mode = mode;
    state.alert.line = line;
    state.alert.dest = dest;
    state.alert.whenIso = whenIso;
    state.alert.leadMin = Math.max(0, Number(leadMin) || 0);
    state.alert.timerId = null;

    updateAlertBar();

    const depMs = new Date(whenIso).getTime();
    const triggerMs = depMs - (state.alert.leadMin + 2) * 60000;
    const delay = triggerMs - Date.now();

    if (delay <= 0) {
      fireAlert(`${line} â†’ ${dest}: leave now`);
      return;
    }

    state.alert.timerId = setTimeout(() => {
      fireAlert(`${line} â†’ ${dest}: leave in 2 min`);
    }, delay);
  }

  function cancelAlert() {
    clearAlertTimer();
    state.alert.active = false;
    state.alert.mode = null;
    state.alert.line = null;
    state.alert.dest = null;
    state.alert.whenIso = null;
    state.alert.leadMin = 0;
    updateAlertBar();
  }

  // Resync alert to next matching future departure after each refresh (handles real-time changes)
  function resyncAlertFromList(deps, leadMin) {
    if (!state.alert.active) return;
    if (!deps || !deps.length) return;

    const wantLine = norm(state.alert.line);
    const wantDest = String(state.alert.dest || '').toLowerCase();

    const candIso = (deps || [])
            .filter(d => norm(d.line?.name) === wantLine)
            .filter(d => bestDest(d).toLowerCase().includes(wantDest))
            .map(d => (d.when || d.plannedWhen))
            .filter(iso => isFuture(iso))
            .sort((a,b)=>new Date(a)-new Date(b))[0];

    if (candIso && candIso !== state.alert.whenIso) {
      scheduleAlertForDeparture({
        mode: state.alert.mode,
        line: state.alert.line,
        dest: state.alert.dest,
        whenIso: candIso,
        leadMin
      });
    }
  }

  // Unlock audio on first click (helps WebAudio beep)
  document.addEventListener('click', () => {
    try {
      const ctx = new (window.AudioContext || window.webkitAudioContext)();
      ctx.resume();
      ctx.close();
    } catch {}
  }, { once: true });

  // =====================
  // API helpers
  // =====================
  async function fetchJson(url) {
    const res = await fetch(url, { headers: { 'accept': 'application/json' } });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.json();
  }

  async function resolveStopId(name) {
    if (!name || !name.trim()) throw new Error('Empty stop name');
    const key = name.trim();
    if (state.cache.has(key)) return state.cache.get(key);

    const q = encodeURIComponent(key);
    const url = `${API_BASE}/locations?query=${q}&stops=true&poi=false&addresses=false&results=10&fuzzy=true`;
    const arr = await fetchJson(url);
    if (!Array.isArray(arr) || arr.length === 0) throw new Error(`No station found for: ${key}`);

    const stopish = arr.find(x => (x.type === 'stop' || x.type === 'station')) || arr[0];
    const id = stopish?.id;
    if (!id) throw new Error(`No id for: ${key}`);

    state.cache.set(key, id);
    return id;
  }

  async function getDepartures(stopId, { results = 120, duration = 180, busOnly = false, stopovers = false } = {}) {
    const params = new URLSearchParams();
    params.set('results', String(results));
    params.set('duration', String(duration));
    if (stopovers) params.set('stopovers', 'true');

    if (busOnly) {
      params.set('bus', 'true');
      params.set('suburban', 'false');
      params.set('subway', 'false');
      params.set('tram', 'false');
      params.set('ferry', 'false');
      params.set('express', 'false');
      params.set('regional', 'false');
    }
    const url = `${API_BASE}/stops/${encodeURIComponent(stopId)}/departures?${params.toString()}`;
    const resp = await fetchJson(url);
    if (Array.isArray(resp)) return resp;
    return resp?.departures || [];
  }

  async function getJourneys(fromId, toId, { results = 1 } = {}) {
    const params = new URLSearchParams();
    params.set('from', fromId);
    params.set('to', toId);
    params.set('results', String(results));
    const url = `${API_BASE}/journeys?${params.toString()}`;
    return await fetchJson(url);
  }

  // =====================
  // Rendering (adds ðŸ”” button)
  // =====================
  function renderDepartureTable(title, deps) {
    const filtered = (deps || []).filter(d => isFuture(d.when || d.plannedWhen));
    if (!filtered.length) return `<div class="muted">${escapeHtml(title)}: no departures found.</div>`;

    const rows = filtered.map(d => {
      const when = d.when || d.plannedWhen;

      // S-Bahn shows minimum 3 minutes always.
      const mins = minutesFromNow(when, minDisplayForDeparture(d));
      if (mins == null) return '';

      const line = d.line?.name || 'â€”';
      const dir = bestDest(d);
      const plat = d.platform ? `Pl. ${d.platform}` : '';
      return `
        <tr>
          <td style="width:64px;"><span class="pill ${pillClass(mins)}">${mins} min</span></td>
          <td>
            <div><b>${escapeHtml(line)}</b> â†’ ${escapeHtml(dir)}</div>
            <div class="muted">${fmtTime(when)} ${escapeHtml(plat)}</div>
          </td>
          <td style="width:72px;">
            <button class="alertBtn" data-line="${escapeHtml(line)}" data-dest="${escapeHtml(dir)}" data-when="${escapeHtml(when)}">ðŸ””</button>
          </td>
        </tr>
      `;
    }).join('');

    return `
      <div class="muted" style="margin:6px 0 8px;">${escapeHtml(title)}</div>
      <table>
        <thead><tr><th>In</th><th>Service</th><th>Alert</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  // =====================
  // Home mode
  // =====================
  async function loadHome() {
    const cfg = state.cfg;

    const [stopA, stopB, sAdlershof, sAltglienicke] = await Promise.all([
      resolveStopId(cfg.homeStopA),
      resolveStopId(cfg.homeStopB),
      resolveStopId(cfg.homeTargetA),
      resolveStopId(cfg.homeTargetB),
    ]);

    // Bus departures at home stops
    const [depsAAll, depsBAll] = await Promise.all([
      getDepartures(stopA, { busOnly: true, results: 120, duration: 180 }),
      getDepartures(stopB, { busOnly: true, results: 120, duration: 180 }),
    ]);

    const depsA = (depsAAll || [])
            .filter(d => cfg.homeLinesA.includes(d.line?.name))
            .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 8);

    const depsB = (depsBAll || [])
            .filter(d => cfg.homeLinesB.includes(d.line?.name))
            .filter(d => homeBusAllowed(d.line?.name, bestDest(d)))
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 8);

    state.last.homeA = depsA;
    state.last.homeB = depsB;

    $('departures').innerHTML =
            renderDepartureTable(`${cfg.homeStopA}: 260/163 â†’ Adlershof (163 may also go SchÃ¶neweide)`, depsA)
            + `<div style="height:10px"></div>`
            + renderDepartureTable(`${cfg.homeStopB}: 160 â†’ Altglienicke`, depsB);

    // Keep the original Home functionality unchanged beyond the S-min-display clamp
    const [jAtoAdl, jBtoAlt] = await Promise.all([
      getJourneys(stopA, sAdlershof, { results: 1 }),
      getJourneys(stopB, sAltglienicke, { results: 1 }),
    ]);

    const arriveAdlershofIso = jAtoAdl?.journeys?.[0]?.legs?.at(-1)?.arrival || null;
    const arriveAltglienickeIso = jBtoAlt?.journeys?.[0]?.legs?.at(-1)?.arrival || null;

    const arrAdlMs = arriveAdlershofIso ? new Date(arriveAdlershofIso).getTime() : null;
    const arrAltMs = arriveAltglienickeIso ? new Date(arriveAltglienickeIso).getTime() : null;

    const [adlDepsAll, altDepsAll] = await Promise.all([
      getDepartures(sAdlershof, { busOnly: false, results: 260, duration: 240 }),
      getDepartures(sAltglienicke, { busOnly: false, results: 260, duration: 240 }),
    ]);

    const adlCity = (adlDepsAll || [])
            .filter(d => d.line?.product === 'suburban')
            .filter(d => adlershofCityAllowed(d.line?.name, bestDest(d)))
            .filter(d => {
              const t = new Date(d.when || d.plannedWhen).getTime();
              return arrAdlMs ? (t > arrAdlMs) : (t > Date.now());
            })
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 6);

    const altCity = (altDepsAll || [])
            .filter(d => d.line?.product === 'suburban')
            .filter(d => altglienickeCityAllowed(d.line?.name, bestDest(d)))
            .filter(d => {
              const t = new Date(d.when || d.plannedWhen).getTime();
              return arrAltMs ? (t > arrAltMs) : (t > Date.now());
            })
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 6);

    state.last.homeAdlS = adlCity;
    state.last.homeAltS = altCity;

    $('connections').innerHTML = `
      <div class="muted">${escapeHtml(cfg.homeStopA)} â†’ ${escapeHtml(cfg.homeTargetA)}</div>
      <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAdlershofIso)}</div>
      ${renderDepartureTable(`${cfg.homeTargetA}: city-center S (includes S8 Blankenburg)`, adlCity)}
      <div style="height:10px"></div>
      <div class="muted">${escapeHtml(cfg.homeStopB)} â†’ ${escapeHtml(cfg.homeTargetB)}</div>
      <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAltglienickeIso)}</div>
      ${renderDepartureTable(`${cfg.homeTargetB}: S9 + S85 (if present)`, altCity)}
    `;

    if (state.alert.active && state.alert.mode === 'home') {
      const leadMin = Number(state.cfg.homeToStopMin) || 0;
      const combined = [...(state.last.homeA||[]), ...(state.last.homeB||[]), ...(state.last.homeAdlS||[]), ...(state.last.homeAltS||[])];
      resyncAlertFromList(combined, leadMin);
    }

    $('homeWork').innerHTML = '';
  }

  // =====================
  // Work mode
  // =====================
  async function loadWork() {
    const cfg = state.cfg;
    const tiergartenId = await resolveStopId(cfg.workS);

    const now = Date.now();
    const etaTiergarten = new Date(now + (Number(cfg.workToTiergartenMin) || 7) * 60000);

    const depsAll = await getDepartures(tiergartenId, { busOnly: false, results: 280, duration: 240 });

    const depsS = (depsAll || [])
            .filter(d => d.line?.product === 'suburban')
            // Enforce *again* at object-level to prevent any S9â†’Spandau from slipping through
            .filter(d => workSAllowed(d.line?.name, bestDest(d)))
            .filter(d => {
              const ln = norm(d.line?.name);
              const dest = bestDest(d).toLowerCase();
              if (ln === 'S9' && dest.includes('spandau')) return false;
              return true;
            })
            .filter(d => new Date(d.when || d.plannedWhen).getTime() > etaTiergarten.getTime())
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 12);

    state.last.workS = depsS;

    const header = `
      <div class="muted" style="margin:6px 0 8px;">
        Buffer: work â†’ ${escapeHtml(cfg.workS)} <b>${Number(cfg.workToTiergartenMin)||7} min</b>.
        Earliest departure â‰¥ <b>${etaTiergarten.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</b>.
      </div>
    `;

    $('departures').innerHTML =
            header +
            renderDepartureTable(`${cfg.workS}: only S5â†’Strausberg, S7â†’Ahrensfelde, S3â†’Erkner, S9â†’Flughafen BER`, depsS);

    $('comparison').innerHTML = `<div class="muted">Regio boards are in separate modes (Hauptbahnhof/Ostkreuz/SchÃ¶neweide).</div>`;

    if (state.alert.active && state.alert.mode === 'work') {
      const leadMin = Number(state.cfg.workToTiergartenMin) || 7;
      resyncAlertFromList(state.last.workS, leadMin);
    }
  }

  // =====================
  // Regio modes
  // =====================
  async function loadRegioMode(which) {
    const cfg = state.cfg;

    // ----- Ostkreuz: two-direction split (KEEP BOTH) -----
    if (which === 'ost') {
      const stopName = cfg.regioOstkreuzName;
      const stopId = await resolveStopId(stopName);

      // stopovers=true to reliably include RB32 that passes SchÃ¶neweide
      const depsAll = await getDepartures(stopId, { busOnly: false, results: 360, duration: 360, stopovers: true });

      const base = (depsAll || [])
              .filter(d => ['regional','express'].includes(d.line?.product))
              .filter(d => isFuture(d.when || d.plannedWhen))
              .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));

      // A) Ostkreuz -> "Hauptbahnhof direction" (your original Ostkreuz block)
      const allowToHbf = new Set(['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02','RE7','RE 7','RE07','RE 07'].map(norm));
      const depsToHbf = base
              .filter(d => allowToHbf.has(norm(d.line?.name)))
              .filter(d => {
                const dest = bestDest(d).toLowerCase();
                // match exactly what you had previously
                return dest.includes('genthin') || dest.includes('dessau') || dest.includes('hennigsdorf');
              })
              .slice(0, 14);

      // B) Ostkreuz -> SchÃ¶neweide direction: show RB24 + RB32 that stop at SchÃ¶neweide (regardless of final destination)
      const allowToSw = new Set(['RB24','RB 24','RB32','RB 32'].map(norm));
      const depsToSw = base
              .filter(d => allowToSw.has(norm(d.line?.name)))
              .filter(d => hasStopover(d, 'SchÃ¶neweide') || hasStopover(d, 'Schoeneweide'))
              .slice(0, 14);

      state.last.ost = [...depsToHbf, ...depsToSw];

      $('departures').innerHTML =
              renderDepartureTable(`${stopName}: towards Hauptbahnhof (RE1â†’Genthin, RE7â†’Dessau, RE2â†’Hennigsdorf)`, depsToHbf) +
              `<div style="height:12px"></div>` +
              renderDepartureTable(`${stopName}: towards SchÃ¶neweide (RB24/RB32 via SchÃ¶neweide)`, depsToSw);

      $('comparison').innerHTML = `<div class="muted">Ostkreuz: split direction board.</div>`;
      return;
    }

    // ----- Other regio modes unchanged -----
    let stopName = '';
    let title = '';
    let allowLines = new Set();
    let destMatchers = [];

    if (which === 'hbf') {
      stopName = cfg.regioHbfName;
      title = `${stopName}: RE2â†’Cottbus, RE1â†’Frankfurt (Oder)`;
      allowLines = new Set(['RE1','RE 1','RE01','RE 01','RE2','RE 2','RE02','RE 02'].map(norm));
      destMatchers = [
        (dest) => (dest.includes('frankfurt') && dest.includes('oder')),
        (dest) => dest.includes('cottbus'),
      ];
    } else if (which === 'sw') {
      stopName = cfg.regioSchoneweideName;
      title = `${stopName}: RB32/RB24 towards Ostkreuz/Hbf`;
      allowLines = new Set(['RB32','RB 32','RB24','RB 24'].map(norm));
      destMatchers = [
        (dest) => dest.includes('ostkreuz'),
        (dest) => dest.includes('hauptbahnhof') || dest.includes('berlin hbf') || dest === 'hbf',
      ];
    } else {
      throw new Error('Unknown Regio mode');
    }

    const stopId = await resolveStopId(stopName);
    const depsAll = await getDepartures(stopId, { busOnly: false, results: 320, duration: 300 });

    const deps = (depsAll || [])
            .filter(d => ['regional','express'].includes(d.line?.product))
            .filter(d => allowLines.has(norm(d.line?.name)))
            .filter(d => {
              const dest = bestDest(d).toLowerCase();
              return destMatchers.some(m => m(dest));
            })
            .filter(d => isFuture(d.when || d.plannedWhen))
            .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
            .slice(0, 16);

    if (which === 'hbf') state.last.hbf = deps;
    if (which === 'sw') state.last.sw = deps;

    $('departures').innerHTML = renderDepartureTable(title, deps);
    $('comparison').innerHTML = `<div class="muted">Regio board mode.</div>`;
  }

  // =====================
  // App controls
  // =====================
  function applyCfgToInputs() {
    $('inHomeStopA').value = state.cfg.homeStopA;
    $('inHomeStopB').value = state.cfg.homeStopB;
    $('inHomeTargetA').value = state.cfg.homeTargetA;
    $('inHomeTargetB').value = state.cfg.homeTargetB;
    $('inHomeWalk').value = String(state.cfg.homeToStopMin || 0);
    $('inWorkS').value = state.cfg.workS;
    $('inWorkWalk').value = String(state.cfg.workToTiergartenMin || 7);
    $('inRegioHbf').value = state.cfg.regioHbfName;
    $('inRegioOst').value = state.cfg.regioOstkreuzName;
    $('inRegioSW').value = state.cfg.regioSchoneweideName;
  }

  function readInputsToCfg() {
    state.cfg.homeStopA = $('inHomeStopA').value.trim();
    state.cfg.homeStopB = $('inHomeStopB').value.trim();
    state.cfg.homeTargetA = $('inHomeTargetA').value.trim();
    state.cfg.homeTargetB = $('inHomeTargetB').value.trim();
    state.cfg.workS = $('inWorkS').value.trim();

    const hw = Number(($('inHomeWalk').value || '').trim());
    state.cfg.homeToStopMin = (Number.isFinite(hw) && hw >= 0) ? hw : 0;

    const ww = Number(($('inWorkWalk').value || '').trim());
    state.cfg.workToTiergartenMin = (Number.isFinite(ww) && ww > 0) ? ww : 7;

    state.cfg.regioHbfName = $('inRegioHbf').value.trim();
    state.cfg.regioOstkreuzName = $('inRegioOst').value.trim();
    state.cfg.regioSchoneweideName = $('inRegioSW').value.trim();

    state.cache.clear();
  }

  function setMode(mode) {
    state.mode = mode;
    ['home','work','hbf','ost','sw'].forEach(m => {
      const el = document.getElementById(`tab-${m}`);
      if (el) el.classList.toggle('active', m === mode);
    });

    $('modeTitle').textContent =
            mode === 'home' ? 'Home mode'
                    : mode === 'work' ? 'Work mode'
                            : mode === 'hbf' ? 'Hauptbahnhof mode'
                                    : mode === 'ost' ? 'Ostkreuz mode'
                                            : 'SchÃ¶neweide mode';

    $('modeSubtitle').textContent =
            mode === 'home' ? 'Altglienicke buses + S-Bahn options'
                    : mode === 'work' ? 'Tiergarten S-Bahn (strict directions)'
                            : 'Regio board';

    $('homeOnlyCard').style.display = (mode === 'home') ? 'block' : 'none';
    $('comparisonCard').style.display = 'block';

    if (mode !== 'home') {
      $('connections').innerHTML = '';
      $('homeWork').innerHTML = '';
    }
  }

  async function refresh() {
    setError('');
    $('btnRefresh').disabled = true;
    const started = new Date();
    setStatus('Loadingâ€¦');
    try {
      if (state.mode === 'home') await loadHome();
      else if (state.mode === 'work') await loadWork();
      else if (state.mode === 'hbf') await loadRegioMode('hbf');
      else if (state.mode === 'ost') await loadRegioMode('ost');
      else if (state.mode === 'sw') await loadRegioMode('sw');

      setStatus(`Updated ${started.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`);
      updateAlertBar();
    } catch (e) {
      setError(String(e?.message || e));
      setStatus('');
    } finally {
      $('btnRefresh').disabled = false;
    }
  }

  function toggleAuto() {
    state.auto = !state.auto;
    $('btnAuto').textContent = state.auto ? 'Auto: On (60s)' : 'Auto: Off';
    if (state.auto) {
      refresh();
      state.autoTimer = setInterval(refresh, 60000);
    } else {
      if (state.autoTimer) clearInterval(state.autoTimer);
      state.autoTimer = null;
    }
  }

  // =====================
  // Event wiring
  // =====================
  loadCfg();
  applyCfgToInputs();

  $('tab-home').addEventListener('click', () => { setMode('home'); refresh(); });
  $('tab-work').addEventListener('click', () => { setMode('work'); refresh(); });
  $('tab-hbf').addEventListener('click', () => { setMode('hbf'); refresh(); });
  $('tab-ost').addEventListener('click', () => { setMode('ost'); refresh(); });
  $('tab-sw').addEventListener('click', () => { setMode('sw'); refresh(); });

  $('btnRefresh').addEventListener('click', refresh);
  $('btnAuto').addEventListener('click', toggleAuto);

  $('btnSave').addEventListener('click', () => {
    readInputsToCfg();
    saveCfg();
    refresh();
  });

  $('btnReset').addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    state.cache.clear();
    state.cfg = {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter SchÃ¶nefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      homeLinesA: ['260','163'],
      homeLinesB: ['160'],
      homeToStopMin: 0,
      workS: 'S Tiergarten',
      workToTiergartenMin: 7,
      regioHbfName: 'Berlin Hbf',
      regioOstkreuzName: 'S Ostkreuz',
      regioSchoneweideName: 'S SchÃ¶neweide',
    };
    applyCfgToInputs();
    refresh();
  });

  $('btnAlertCancel').addEventListener('click', () => cancelAlert());

  // ðŸ”” click handling (event delegation)
  document.addEventListener('click', async (e) => {
    const btn = e.target.closest('.alertBtn');
    if (!btn) return;

    await ensureNotificationPermission();

    const line = btn.dataset.line;
    const dest = btn.dataset.dest;
    const whenIso = btn.dataset.when;

    const leadMin = (state.mode === 'work') ? (Number(state.cfg.workToTiergartenMin) || 7)
            : (state.mode === 'home') ? (Number(state.cfg.homeToStopMin) || 0)
                    : 0;

    if (state.mode !== 'home' && state.mode !== 'work') {
      setStatus('Alerts are available only in Home or Work mode.');
      return;
    }

    scheduleAlertForDeparture({
      mode: state.mode,
      line,
      dest,
      whenIso,
      leadMin
    });

    setStatus(`Alert set: ${line} â†’ ${dest}`);
  });

  // Start
  setMode('home');
  refresh();
</script>
</body>
</html>
