<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <meta name="theme-color" content="#111827" />
  <title>Berlin Transit Quickboard</title>
  <style>
    :root { --bg:#0b1220; --card:#111827; --muted:#93a4b8; --text:#e5e7eb; --accent:#60a5fa; --ok:#34d399; --warn:#fbbf24; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    header { position:sticky; top:0; background:rgba(11,18,32,.92); backdrop-filter: blur(10px); border-bottom:1px solid rgba(255,255,255,.08); padding:14px 14px 10px; }
    h1 { font-size:16px; margin:0 0 10px; font-weight:700; letter-spacing:.2px; }
    .tabs { display:flex; gap:8px; }
    .tab { flex:1; padding:10px 12px; border-radius:12px; background:var(--card); border:1px solid rgba(255,255,255,.08); color:var(--text); font-weight:700; cursor:pointer; }
    .tab.active { outline:2px solid rgba(96,165,250,.45); border-color: rgba(96,165,250,.45); }

    main { padding:14px; display:grid; gap:12px; max-width: 720px; margin:0 auto; }
    .card { background:var(--card); border:1px solid rgba(255,255,255,.08); border-radius:16px; padding:12px; }
    .card h2 { margin:0 0 10px; font-size:14px; }
    .row { display:flex; justify-content:space-between; align-items:baseline; gap:10px; }
    .muted { color:var(--muted); font-size:12px; }
    .btnrow { display:flex; gap:8px; flex-wrap:wrap; }
    button { background:#0f172a; color:var(--text); border:1px solid rgba(255,255,255,.1); padding:10px 12px; border-radius:12px; font-weight:700; cursor:pointer; }
    button.primary { background:rgba(96,165,250,.16); border-color: rgba(96,165,250,.45); }
    button:disabled { opacity:.5; cursor:not-allowed; }

    table { width:100%; border-collapse:collapse; font-size:13px; }
    td, th { padding:8px 6px; border-top:1px solid rgba(255,255,255,.08); vertical-align:top; }
    th { text-align:left; color:var(--muted); font-size:12px; font-weight:700; border-top:none; }
    .pill { display:inline-flex; align-items:center; gap:6px; padding:2px 8px; border-radius:999px; font-size:12px; border:1px solid rgba(255,255,255,.12); }
    .pill.ok { border-color: rgba(52,211,153,.5); color: var(--ok); }
    .pill.warn { border-color: rgba(251,191,36,.6); color: var(--warn); }
    .pill.bad { border-color: rgba(251,113,133,.6); color: var(--bad); }

    .grid2 { display:grid; grid-template-columns: 1fr; gap:12px; }
    @media (min-width: 640px) { .grid2 { grid-template-columns: 1fr 1fr; } }

    input { width:100%; box-sizing:border-box; padding:10px 12px; border-radius:12px; border:1px solid rgba(255,255,255,.12); background:#0f172a; color:var(--text); }
    .small { font-size:12px; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    .error { color: var(--bad); font-size: 12px; margin-top: 8px; }
  </style>
</head>
<body>
<header>
  <h1>Berlin Transit Quickboard</h1>
  <div class="tabs">
    <button id="tab-home" class="tab active">Home</button>
    <button id="tab-work" class="tab">Work</button>
  </div>
</header>

<main>
  <div class="card">
    <div class="row">
      <div>
        <div id="modeTitle" style="font-weight:800; font-size:14px;">Home mode</div>
        <div id="modeSubtitle" class="muted">Altglienicke buses + S-Bahn options</div>
      </div>
      <div class="btnrow">
        <button id="btnRefresh" class="primary">Refresh</button>
        <button id="btnAuto">Auto: Off</button>
      </div>
    </div>
    <div class="muted" style="margin-top:8px;">
      Uses vbb.transport.rest (<span class="mono" id="apiBase"></span>). Data includes realtime delays when available.
    </div>
    <div id="status" class="muted" style="margin-top:8px;"></div>
    <div id="err" class="error" style="display:none;"></div>
  </div>

  <div class="grid2">
    <div class="card">
      <h2>Departures</h2>
      <div class="muted">Top 3 (filtered). Times are realtime when provided.</div>
      <div id="departures"></div>
    </div>

    <div class="card">
      <h2>Which option is better?</h2>
      <div class="muted">Home: earliest catchable S9 → Spandau after you arrive at the S-Bahn.</div>
      <div id="comparison"></div>
    </div>
  </div>

  <div class="card" id="homeOnlyCard">
    <h2>What train will I catch?</h2>
    <div class="muted">Estimates your arrival at the S-Bahn and shows departures after you arrive.</div>
    <div id="connections"></div>
    <div id="homeWork" style="margin-top:12px;"></div>
  </div>

  <div class="card">
    <h2>Settings (optional)</h2>
    <div class="muted">Override stop names if lookup resolves wrong one.</div>
    <div class="grid2" style="margin-top:10px;">
      <div>
        <div class="muted small">Home: primary bus stop</div>
        <input id="inHomeStopA" value="Altglienicke Kirche" />
      </div>
      <div>
        <div class="muted small">Home: secondary bus stop</div>
        <input id="inHomeStopB" value="Alter Schönefelder Weg" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target A</div>
        <input id="inHomeTargetA" value="S Adlershof" />
      </div>
      <div>
        <div class="muted small">Home: S-Bahn target B</div>
        <input id="inHomeTargetB" value="S Altglienicke" />
      </div>
      <div>
        <div class="muted small">Work: S station</div>
        <input id="inWorkS" value="S Tiergarten" />
      </div>
      <div>
        <div class="muted small">Work: Hbf</div>
        <input id="inWorkHbf" value="Berlin Hbf" />
      </div>
    </div>
    <div class="btnrow" style="margin-top:10px;">
      <button id="btnSave">Save</button>
      <button id="btnReset">Reset</button>
    </div>
  </div>
</main>

<script>
  // =====================
  // API
  // =====================
  const API_BASE = 'https://v6.vbb.transport.rest';
  document.getElementById('apiBase').textContent = API_BASE;

  const state = {
    mode: 'home',
    auto: false,
    autoTimer: null,
    cache: new Map(),
    cfg: {
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter Schönefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      workS: 'S Tiergarten',
      workHbf: 'Berlin Hbf',

      // home buses
      homeLinesA: ['260', '163'],
      homeLinesB: ['160'],

      // work S lines (filtered)
      workTiergartenLines: ['S9','S 9','S7','S 7','S5','S 5','S3','S 3'],

      // walking buffers
      workToTiergartenMin: 10,
      tiergartenToHbfMin: 8,

      // work regios you care about
      workRegioLines: ['RE2','RE 2','RE1','RE 1'],
      workRegioDirKeywords: ['cottbus', 'frankfurt'] // Frankfurt (Oder)
    }
  };

  // ---------- persistence ----------
  const LS_KEY = 'btqb_cfg_v1';
  function loadCfg() {
    try {
      const raw = localStorage.getItem(LS_KEY);
      if (!raw) return;
      const parsed = JSON.parse(raw);
      state.cfg = { ...state.cfg, ...parsed };
    } catch {}
  }
  function saveCfg() { localStorage.setItem(LS_KEY, JSON.stringify(state.cfg)); }

  // ---------- utils ----------
  const $ = (id) => document.getElementById(id);

  function setStatus(msg) { $('status').textContent = msg; }
  function setError(msg) {
    const el = $('err');
    if (!msg) { el.style.display = 'none'; el.textContent = ''; return; }
    el.style.display = 'block';
    el.textContent = msg;
  }

  function fmtTime(iso) {
    if (!iso) return '—';
    const d = new Date(iso);
    return d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'});
  }

  function minutesFromNow(iso) {
    if (!iso) return null;
    const ms = new Date(iso).getTime() - Date.now();
    return Math.round(ms / 60000);
  }

  function pillClass(mins) {
    if (mins == null) return 'warn';
    if (mins <= 3) return 'bad';
    if (mins <= 8) return 'warn';
    return 'ok';
  }

  function escapeHtml(s) {
    return String(s || '').replace(/[&<>"]+/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;'}[c] || c));
  }

  const norm = (s) => String(s || '').toUpperCase().replaceAll(' ', '');

  function bestDest(d) {
    return String(d.direction || d.destination?.name || d.trip?.destination?.name || '');
  }

  async function fetchJson(url) {
    const res = await fetch(url, { headers: { 'accept': 'application/json' } });
    if (!res.ok) throw new Error(`HTTP ${res.status} for ${url}`);
    return await res.json();
  }

  // v6 stop lookup via /locations
  async function resolveStopId(name) {
    if (!name || !name.trim()) throw new Error('Empty stop name');
    const key = name.trim();
    if (state.cache.has(key)) return state.cache.get(key);

    const q = encodeURIComponent(key);
    const url = `${API_BASE}/locations?query=${q}&stops=true&poi=false&addresses=false&results=10&fuzzy=true`;
    const arr = await fetchJson(url);

    if (!Array.isArray(arr) || arr.length === 0) throw new Error(`No result for: ${key}`);

    const stopish =
      arr.find(x => x && (x.type === 'stop' || x.type === 'station')) ||
      arr[0];

    const id = stopish?.id;
    if (!id) throw new Error(`No id for: ${key}`);

    state.cache.set(key, id);
    return id;
  }

  async function getDepartures(stopId, { results = 20, duration = 40, directionId = null, busOnly = false } = {}) {
    const params = new URLSearchParams();
    params.set('results', String(results));
    params.set('duration', String(duration));
    if (busOnly) {
      params.set('bus', 'true');
      params.set('suburban', 'false');
      params.set('subway', 'false');
      params.set('tram', 'false');
      params.set('ferry', 'false');
      params.set('express', 'false');
      params.set('regional', 'false');
    }
    if (directionId) params.set('direction', directionId);

    const url = `${API_BASE}/stops/${encodeURIComponent(stopId)}/departures?${params.toString()}`;
    const resp = await fetchJson(url);
    if (Array.isArray(resp)) return resp;
    return resp?.departures || [];
  }

  async function getJourneys(fromId, toId, { results = 1, departure = null } = {}) {
    const params = new URLSearchParams();
    params.set('from', fromId);
    params.set('to', toId);
    params.set('results', String(results));
    if (departure) params.set('departure', departure);
    const url = `${API_BASE}/journeys?${params.toString()}`;
    return await fetchJson(url);
  }

  function renderDepartureTable(title, deps) {
    if (!deps || deps.length === 0) {
      return `<div class="muted">${title}: no departures found.</div>`;
    }
    const rows = deps.map(d => {
      const when = d.when || d.plannedWhen;
      const mins = minutesFromNow(when);
      const line = d.line?.name || '—';
      const dir = bestDest(d);
      const plat = d.platform ? `Pl. ${d.platform}` : '';
      return `
        <tr>
          <td style="width:64px;"><span class="pill ${pillClass(mins)}">${mins ?? '—'} min</span></td>
          <td><div><b>${escapeHtml(line)}</b> → ${escapeHtml(dir)}</div><div class="muted">${fmtTime(when)} ${escapeHtml(plat)}</div></td>
        </tr>
      `;
    }).join('');

    return `
      <div class="muted" style="margin:6px 0 8px;">${title}</div>
      <table>
        <thead><tr><th>In</th><th>Service</th></tr></thead>
        <tbody>${rows}</tbody>
      </table>
    `;
  }

  // =====================
  // HOME MODE
  // =====================
  async function loadHome() {
    const cfg = state.cfg;

    // Resolve ids
    const [stopA, stopB, sAdlershof, sAltglienicke] = await Promise.all([
      resolveStopId(cfg.homeStopA),
      resolveStopId(cfg.homeStopB),
      resolveStopId(cfg.homeTargetA),
      resolveStopId(cfg.homeTargetB),
    ]);

    // Bus departures at both stops
    const [depsAAll, depsBAll] = await Promise.all([
      getDepartures(stopA, { busOnly: true, results: 60, duration: 60 }),
      getDepartures(stopB, { busOnly: true, results: 60, duration: 60 }),
    ]);

    const depsA = (depsAAll || []).filter(d => cfg.homeLinesA.includes(d.line?.name)).slice(0, 3);
    const depsB = (depsBAll || []).filter(d => cfg.homeLinesB.includes(d.line?.name)).slice(0, 3);

    $('departures').innerHTML =
      renderDepartureTable(`${cfg.homeStopA}: lines ${cfg.homeLinesA.join(', ')}`, depsA)
      + `<div style="height:10px"></div>`
      + renderDepartureTable(`${cfg.homeStopB}: line ${cfg.homeLinesB.join(', ')}`, depsB);

    // Journeys to S stations (arrival estimates)
    const [jAtoAdl, jBtoAlt] = await Promise.all([
      getJourneys(stopA, sAdlershof, { results: 1 }),
      getJourneys(stopB, sAltglienicke, { results: 1 }),
    ]);

    const arriveAdlershofIso = jAtoAdl?.journeys?.[0]?.legs?.at(-1)?.arrival || null;
    const arriveAltglienickeIso = jBtoAlt?.journeys?.[0]?.legs?.at(-1)?.arrival || null;

    // Departures from S stations
    const [adlDepsAll, altDepsAll] = await Promise.all([
      getDepartures(sAdlershof, { results: 120, duration: 120 }),
      getDepartures(sAltglienicke, { results: 120, duration: 120 }),
    ]);

    // From Adlershof: show S9/S8/S85 towards city-center-ish directions
    const adlCity = (adlDepsAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => ['S9','S8','S85'].includes(norm(d.line?.name)))
      .filter(d => {
        const dest = bestDest(d).toLowerCase();
        return dest.includes('spandau') || dest.includes('birkenwerder') || dest.includes('westend') || dest.includes('pankow');
      })
      .filter(d => !arriveAdlershofIso || new Date(d.when || d.plannedWhen).getTime() >= new Date(arriveAdlershofIso).getTime())
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))
      .slice(0, 5);

    // From Altglienicke: show S9, prefer destination Spandau, but never hide S9 completely
    const altAfterArr = (altDepsAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => !arriveAltglienickeIso || new Date(d.when || d.plannedWhen).getTime() >= new Date(arriveAltglienickeIso).getTime())
      .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen));

    const altS9Any = altAfterArr
      .filter(d => norm(d.line?.name) === 'S9')
      .slice(0, 5);

    const altS9Spandau = altAfterArr
      .filter(d => norm(d.line?.name) === 'S9')
      .filter(d => bestDest(d).toLowerCase().includes('spandau'))
      .slice(0, 5);

    const altS9ToShow = altS9Spandau.length ? altS9Spandau : altS9Any;

    $('connections').innerHTML =
      `<div class="muted">${escapeHtml(cfg.homeStopA)} → ${escapeHtml(cfg.homeTargetA)}</div>
       <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAdlershofIso)}</div>
       ${renderDepartureTable(`${cfg.homeTargetA}: next S9/S8/S85 towards city`, adlCity)}
       <div style="height:12px"></div>
       <div class="muted">${escapeHtml(cfg.homeStopB)} → ${escapeHtml(cfg.homeTargetB)}</div>
       <div style="font-weight:800; margin:4px 0 8px;">Arrive ~ ${fmtTime(arriveAltglienickeIso)}</div>
       ${renderDepartureTable(
          `${cfg.homeTargetB}: ${altS9Spandau.length ? 'next S9 → Spandau' : 'next S9 (Spandau not found in window; showing any S9)'}`,
          altS9ToShow
        )}
      `;

    // ---------- Home comparison: earliest catchable S9 → Spandau after arrival ----------
    async function nextS9SpandauAfter(stationId, arrivalIso) {
      const depsAll = await getDepartures(stationId, { results: 160, duration: 180 });
      const arrMs = arrivalIso ? new Date(arrivalIso).getTime() : Date.now();
      const cand = (depsAll || [])
        .filter(d => d.line?.product === 'suburban')
        .filter(d => norm(d.line?.name) === 'S9')
        .filter(d => bestDest(d).toLowerCase().includes('spandau'))
        .filter(d => new Date(d.when || d.plannedWhen).getTime() >= arrMs)
        .sort((a,b)=>new Date(a.when||a.plannedWhen)-new Date(b.when||b.plannedWhen))[0];
      return cand || null;
    }

    function totalMinsToBoard(arrivalIso, s9Dep) {
      if (!arrivalIso || !s9Dep) return null;
      const depIso = s9Dep.when || s9Dep.plannedWhen;
      return Math.max(0, Math.round((new Date(depIso).getTime() - Date.now()) / 60000));
    }

    function waitMins(arrivalIso, s9Dep) {
      if (!arrivalIso || !s9Dep) return null;
      const depIso = s9Dep.when || s9Dep.plannedWhen;
      return Math.max(0, Math.round((new Date(depIso).getTime() - new Date(arrivalIso).getTime()) / 60000));
    }

    const [s9FromAdl, s9FromAlt] = await Promise.all([
      nextS9SpandauAfter(sAdlershof, arriveAdlershofIso),
      nextS9SpandauAfter(sAltglienicke, arriveAltglienickeIso),
    ]);

    const optA = {
      label: `${cfg.homeStopA} → ${cfg.homeTargetA} → S9 (Spandau)`,
      arrive: arriveAdlershofIso,
      s9: s9FromAdl,
      total: totalMinsToBoard(arriveAdlershofIso, s9FromAdl),
      wait: waitMins(arriveAdlershofIso, s9FromAdl),
    };

    const optB = {
      label: `${cfg.homeStopB} → ${cfg.homeTargetB} → S9 (Spandau)`,
      arrive: arriveAltglienickeIso,
      s9: s9FromAlt,
      total: totalMinsToBoard(arriveAltglienickeIso, s9FromAlt),
      wait: waitMins(arriveAltglienickeIso, s9FromAlt),
    };

    const opts = [optA, optB].sort((a,b) => (a.total ?? 1e9) - (b.total ?? 1e9));
    const best = opts[0];

    $('comparison').innerHTML = `
      <div class="muted" style="margin-bottom:8px;">Earliest S9 → Spandau you can catch after arriving at the station</div>
      <div style="font-weight:800; margin-bottom:10px;">
        ${best.total == null ? 'No usable S9→Spandau found (check names or time window).' : escapeHtml(best.label)}
      </div>
      <table>
        <thead><tr><th>Total</th><th>Option</th></tr></thead>
        <tbody>
          ${opts.map(o => `
            <tr>
              <td style="width:80px;"><span class="pill ${(o === best && o.total != null) ? 'ok' : 'warn'}">${o.total == null ? '—' : (o.total + ' min')}</span></td>
              <td>
                <b>${escapeHtml(o.label)}</b>
                <div class="muted">Arrive ~ ${fmtTime(o.arrive)} · S9 dep ~ ${fmtTime(o.s9 ? (o.s9.when || o.s9.plannedWhen) : null)} · Wait ~ ${o.wait == null ? '—' : (o.wait + ' min')}</div>
              </td>
            </tr>
          `).join('')}
        </tbody>
      </table>
      ${ (optA.s9 == null || optB.s9 == null) ? `<div class="muted" style="margin-top:10px;">If S9→Spandau is missing: try Settings name “S+U Altglienicke”.</div>` : '' }
    `;

    $('homeWork').innerHTML = '';
  }

  // =====================
  // WORK MODE (unchanged behavior; includes S9 → Flughafen BER)
  // =====================
  async function loadWork() {
    const cfg = state.cfg;

    const [tiergartenId, hbfId] = await Promise.all([
      resolveStopId(cfg.workS),
      resolveStopId(cfg.workHbf),
    ]);

    const now = Date.now();
    const etaTiergarten = new Date(now + cfg.workToTiergartenMin * 60000);
    const etaHbf = new Date(now + (cfg.workToTiergartenMin + cfg.tiergartenToHbfMin) * 60000);

    const depsSAll = await getDepartures(tiergartenId, { busOnly: false, results: 160, duration: 180 });
    const lineSet = new Set(cfg.workTiergartenLines.map(norm));

    const depsS = (depsSAll || [])
      .filter(d => d.line?.product === 'suburban')
      .filter(d => lineSet.has(norm(d.line?.name)))
      .filter(d => {
        const line = norm(d.line?.name);
        const dest = bestDest(d).toLowerCase();

        // only requested:
        if (line === 'S3') return dest.includes('erkner');
        if (line === 'S5') return dest.includes('strausberg');
        if (line === 'S7') return dest.includes('ahrensfelde');

        // S9 to Flughafen BER (not Spandau)
        if (line === 'S9') {
          if (dest.includes('spandau')) return false;
          return dest.includes('flughafen') || dest.includes('ber') || dest.includes('terminal');
        }
        return false;
      })
      .filter(d => new Date(d.when || d.plannedWhen).getTime() >= etaTiergarten.getTime())
      .sort((a,b) => new Date(a.when || a.plannedWhen) - new Date(b.when || b.plannedWhen))
      .slice(0, 8);

    const depsHbfAll = await getDepartures(hbfId, { busOnly: false, results: 200, duration: 180 });
    const regioLineSet = new Set(cfg.workRegioLines.map(norm));
    const regioDirKW = cfg.workRegioDirKeywords.map(x => x.toLowerCase());

    const depsRegio = (depsHbfAll || [])
      .filter(d => ['regional','express'].includes(d.line?.product))
      .filter(d => regioLineSet.has(norm(d.line?.name)))
      .filter(d => {
        const dest = bestDest(d).toLowerCase();
        return regioDirKW.some(k => dest.includes(k));
      })
      .filter(d => new Date(d.when || d.plannedWhen).getTime() >= etaHbf.getTime())
      .sort((a,b) => new Date(a.when || a.plannedWhen) - new Date(b.when || b.plannedWhen))
      .slice(0, 6);

    const header = `
      <div class="muted" style="margin:6px 0 8px;">
        Buffers: work → Tiergarten <b>${cfg.workToTiergartenMin} min</b>, Tiergarten → Hbf <b>${cfg.tiergartenToHbfMin} min</b>.
        Earliest: Tiergarten ≥ <b>${etaTiergarten.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</b>,
        Hbf ≥ <b>${etaHbf.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</b>.
      </div>
    `;

    $('departures').innerHTML =
      header
      + renderDepartureTable(`${cfg.workS}: S3→Erkner, S5→Strausberg Nord, S7→Ahrensfelde, S9→Flughafen BER`, depsS)
      + `<div style="height:10px"></div>`
      + renderDepartureTable(`${cfg.workHbf}: RE1 (Frankfurt (Oder)) + RE2 (Cottbus)`, depsRegio);

    $('comparison').innerHTML = depsS.length
      ? `<div style="font-weight:800;">Next: ${escapeHtml(depsS[0].line?.name)} → ${escapeHtml(bestDest(depsS[0]))} at <b>${fmtTime(depsS[0].when || depsS[0].plannedWhen)}</b></div>`
      : `<div class="muted">No matching Tiergarten trains found. Try Settings: “S+U Tiergarten”.</div>`;
  }

  // =====================
  // App controls
  // =====================
  function applyCfgToInputs() {
    $('inHomeStopA').value = state.cfg.homeStopA;
    $('inHomeStopB').value = state.cfg.homeStopB;
    $('inHomeTargetA').value = state.cfg.homeTargetA;
    $('inHomeTargetB').value = state.cfg.homeTargetB;
    $('inWorkS').value = state.cfg.workS;
    $('inWorkHbf').value = state.cfg.workHbf;
  }

  function readInputsToCfg() {
    state.cfg.homeStopA = $('inHomeStopA').value.trim();
    state.cfg.homeStopB = $('inHomeStopB').value.trim();
    state.cfg.homeTargetA = $('inHomeTargetA').value.trim();
    state.cfg.homeTargetB = $('inHomeTargetB').value.trim();
    state.cfg.workS = $('inWorkS').value.trim();
    state.cfg.workHbf = $('inWorkHbf').value.trim();
    state.cache.clear();
  }

  function setMode(mode) {
    state.mode = mode;
    $('tab-home').classList.toggle('active', mode === 'home');
    $('tab-work').classList.toggle('active', mode === 'work');
    $('modeTitle').textContent = mode === 'home' ? 'Home mode' : 'Work mode';
    $('modeSubtitle').textContent = mode === 'home'
      ? 'Altglienicke buses + S-Bahn options'
      : 'Salzufer 8 → S Tiergarten → Berlin Hbf (RE1/RE2)';

    const homeCard = document.getElementById('homeOnlyCard');
    if (homeCard) homeCard.style.display = (mode === 'home') ? 'block' : 'none';

    if (mode === 'work') {
      const c = document.getElementById('connections');
      const hw = document.getElementById('homeWork');
      if (c) c.innerHTML = '';
      if (hw) hw.innerHTML = '';
    }
  }

  async function refresh() {
    setError('');
    $('btnRefresh').disabled = true;
    const started = new Date();
    setStatus('Loading…');
    try {
      if (state.mode === 'home') await loadHome();
      else await loadWork();
      setStatus(`Updated ${started.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}`);
    } catch (e) {
      setError(String(e?.message || e));
      setStatus('');
    } finally {
      $('btnRefresh').disabled = false;
    }
  }

  function toggleAuto() {
    state.auto = !state.auto;
    $('btnAuto').textContent = state.auto ? 'Auto: On (60s)' : 'Auto: Off';
    if (state.auto) {
      refresh();
      state.autoTimer = setInterval(refresh, 60000);
    } else {
      if (state.autoTimer) clearInterval(state.autoTimer);
      state.autoTimer = null;
    }
  }

  // init
  loadCfg();
  applyCfgToInputs();

  $('tab-home').addEventListener('click', () => { setMode('home'); refresh(); });
  $('tab-work').addEventListener('click', () => { setMode('work'); refresh(); });
  $('btnRefresh').addEventListener('click', refresh);
  $('btnAuto').addEventListener('click', toggleAuto);

  $('btnSave').addEventListener('click', () => {
    readInputsToCfg();
    saveCfg();
    refresh();
  });

  $('btnReset').addEventListener('click', () => {
    localStorage.removeItem(LS_KEY);
    state.cache.clear();
    state.cfg = {
      ...state.cfg,
      homeStopA: 'Altglienicke Kirche',
      homeStopB: 'Alter Schönefelder Weg',
      homeTargetA: 'S Adlershof',
      homeTargetB: 'S Altglienicke',
      workS: 'S Tiergarten',
      workHbf: 'Berlin Hbf',
    };
    applyCfgToInputs();
    refresh();
  });

  refresh();
</script>
</body>
</html>
